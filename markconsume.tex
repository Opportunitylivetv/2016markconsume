\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{epsfig,endnotes}
%\usepackage{usenix,epsfig}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{subfig}
\usepackage{fixltx2e}
\usepackage{url}        % \url{} command with good linebreaks
\usepackage{amssymb,amsmath}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{xspace}
\usepackage{xcolor}
\lstset{basicstyle=\ttfamily}
\usepackage[bookmarks=true,bookmarksnumbered=true,pdfborder={0 0 0}]{hyperref}

% Avoid widows and orphans
\widowpenalty=500
\clubpenalty=500

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\lstset{
	literate={\_}{}{0\discretionary{\_}{}{\_}}%
}
\newcommand{\co}[1]{\lstinline[breaklines=yes,breakatwhitespace=yes]{#1}}

\title{DNNNNR0: Marking {\tt memory\_order\_consume} Dependency Chains}

\author{
{\bf Doc. No.: } WG21/DNNNNR0 \\
{\bf Date: } 2016-03-08 \\
{\bf Reply to: } Paul E. McKenney, Torvald Riegel, Jeff Preshing, \\
	Hans Boehm, Clark Nelson, Olivier Giroux, Lawrence Crowl, \\
	and JF Bastien \\
{\bf Email: } paulmck@linux.vnet.ibm.com, triegel@redhat.com,
jeff@preshing.com \\
boehm@acm.org, clark.nelson@intel.com, OGiroux@nvidia.com, \\
Lawrence@Crowl.org, and jfb@google.com \\ ~ \\
{\bf Other contributors: }
	Alec Teal,
	David Howells,
	David Lang,
	George Spelvin, \\
	Jeff Law,
	Joseph S. Myers,
	Linus Torvalds,
	Mark Batty,
	Michael Matz,
	Peter Sewell, \\
	Peter Zijlstra,
	Ramana Radhakrishnan,
	Richard Biener,
	Will Deacon,
	Faisal Vali, \\
	Behan Webster,
	Tony Tye,
	Thomas Koeppe,
	Jens Maurer,
	... \\
} % end author

% Use the following at camera-ready time to suppress page numbers.
% Comment it out when you first submit the paper for review.
%\thispagestyle{empty}

\pagestyle{myheadings}
\markright{WG21/D0098R1}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This document is based in part on WG21/D0098R1, extracting the
alternatives for marking dependency chains (each headed by a
\co{memory_order_consume}~\cite{RichardSmith2015N4527} load).
It also adds a few additional alternatives based on discussions
at the March 2016 meeting in Jacksonville, Florida,

% A detailed change log appears starting on
% page~\pageref{sec:Change Log}.

\section{Introduction}
\label{sec:Introduction}

Spirited discussions of \co{memory_order_consume}
at the Jacksonville meeting resulted in a few of items of agreement:

\begin{enumerate}
\item	Dependency chains should be restricted to pointers.
\item	Unmarked code can be handled by having the implementation
	behave as if markings had been supplied in all locations that
	could reasonably be marked.
	This allows natural handling of dependencies in unmarked code.
	This behavior should be controlled by a compiler flag.
	Such a flag is of course outside of the standard.
\item	Software artifacts that are built standalone (such as the Linux
	kernel and numerous embedded projects) can reasonably use
	unmarked dependency chains.
	In contrast, software artifacts that are expected to dynamically link
	against standard libraries seem likely to need to mark their
	dependency chains.
\item	Discussions involving marking of library APIs have been
	set aside for the moment, and so this document does not address
	this point.
\end{enumerate}

These points result in three known valid ways of handling
\co{memory_order_consume}:

\begin{enumerate}
\item	Ignore the markings and promote \co{memory_order_consume}
	to \co{memory_order_acquire}, as is current practice.
\item	Ignore the markings, demote \co{memory_order_consume} to
	\co{memory_order_relaxed}, and suppress troublesome
	optimizations of pointers.
	However, there was some difficulty of arriving at a precise
	definition of ``troublesome''.
\item	Demote \co{memory_order_consume} to \co{memory_order_relaxed}
	and suppress troublesome optimizations of marked pointers.
	The fact that such optimizations need not be suppressed
	for unmarked pointers means that a much more conservative
	definition of ``troublesome'' is feasible, thus reducing
	the need for precision.
	Note that pointer comparisons will still break dependency chains
	in some cases, unless the comparisons were carried out using
	proposed dependency-preserving pointer-comparison intrinsics.
\end{enumerate}

However, a number of ways of marking dependency chains have been
proposed and there was nothing resembling any sort of agreement
on which should be used.
This paper therefore catalogs approaches to marking dependency chains,
and evaluates each against a set of representative use cases.

\section{Representative Use Cases}
\label{sec:Representative Use Cases}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 struct rcutest {
 2   int a;
 3   int b;
 4   int c;
 5   spinlock_t lock;
 6 };
 7
 8 struct rcutest1 {
 9   int a;
10   struct rcutest rt;
11 };
12
13 std::atomic<rcutest *> gp;
14 std::atomic<rcutest1 *> g1p;
15 std::atomic<int *> gip;
16 struct rcutest *gslp; /* Global scope, local usage. */
17 std::atomic<rcutest *> gsgp;
18
19 #define rcu_assign_pointer(p, v) \
20   atomic_store_explicit(&(p), (v),
21                         std::memory_order_release);
22 #define rcu_dereference(p) \
23   atomic_load_explicit(&(p), std::memory_order_consume);
\end{verbatim}
}
\caption{Common Definitions}
\label{fig:Common Definitions}
\end{figure}

This section uses the common definitions shown in
Figure~\ref{fig:Common Definitions}
to discuss the use cases in the following list:

\begin{enumerate}
\item	Simple case.
\item	Function in via parameter.
\item	Function out via return value.
\item	Function both in and out, but different chains.
\item	Dependency chain fanning out.
\item	Dependency chain fanning in.
\item	Dependency chain fanning both in and out.
\item	Conditional compilation of endpoint accesses.
\item	Examples involving handoff to locking.
\end{enumerate}

Each of the above use cases is covered in one of the following sections,
followed by a discussion of evaluation criteria.

\subsection{Simple Case}
\label{sec:Simple Case}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void thread0(void)
 2 {
 3   struct rcutest *p;
 4
 5   p = (struct rcutest *)malloc(sizeof(*p));
 6   assert(p);
 7   p->a = 42;
 8   assert(p->a != 43);
 9   rcu_assign_pointer(gp, p);
10 }
11
12 void thread1(void)
13 {
14   struct rcutest *p;
15
16   p = rcu_dereference(gp);
17   if (p)
18     p->a = 43;
19 }
\end{verbatim}
}
\caption{Simple Case}
\label{fig:Simple Case}
\end{figure}

The simple case is shown in
Figure~\ref{fig:Simple Case}.
Here, the dependency chain extends from line~16 through line~18,
where it terminates.
Given the simplicity and compactness of this example, any reasonable
proposal should handle this example simply and naturally.

\subsection{In via Function Parameter}
\label{sec:In via Function Parameter}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void thread0(void)
 2 {
 3   struct rcutest *p;
 4
 5   p = (struct rcutest *)malloc(sizeof(*p));
 6   assert(p);
 7   p->a = 42;
 8   rcu_assign_pointer(gp, p);
 9 }
10
11 void
12 thread1_help(struct rcutest *q)
13 {
14   if (q)
15     assert(q->a == 42);
16 }
17
18 void thread1(void)
19 {
20   struct rcutest *p;
21
22   p = rcu_dereference(gp);
23   thread1_help(p);
24 }
\end{verbatim}
}
\caption{In via Function Parameter}
\label{fig:In via Function Parameter}
\end{figure}

Figure~\ref{fig:In via Function Parameter}
shows an example dependency chain that begins at line~22,
enters function \co{thread1_help()} at line~23,
and then extending from line~12 to line~15 in the called function.
This is a common encapsulation technique.

\subsection{Out via Function Return}
\label{sec:Out via Function Return}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void thread0(void)
 2 {
 3   struct rcutest *p;
 4
 5   p = (struct rcutest *)malloc(sizeof(*p));
 6   assert(p);
 7   p->a = 42;
 8   rcu_assign_pointer(gp, p);
 9 }
10
11 struct rcutest *thread1_help(void)
12 {
13   return rcu_dereference(gp);
14 }
15
16 void thread1(void)
17 {
18   struct rcutest *p;
19
20   p = thread1_help();
21   if (p)
22     assert(p->a == 42);
23 }
\end{verbatim}
}
\caption{Out via Function Return}
\label{fig:Out via Function Return}
\end{figure}

Figure~\ref{fig:Out via Function Return}
shows a dependency chain exiting a function.
It starts at line~21, is returned to line~20, and
terminates on line~22.
This is also a common enscapsuulation technique.

\subsection{In and Out, But Different Chains}
\label{sec:In and Out, But Different Chains}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void thread0(void)
 2 {
 3   struct rcutest *p;
 4
 5   p = (struct rcutest *)malloc(sizeof(*p));
 6   assert(p);
 7   p->a = 42;
 8   rcu_assign_pointer(gp, p);
 9
10   p = (struct rcutest *)malloc(sizeof(*p));
11   assert(p);
12   p->a = 43;
13   rcu_assign_pointer(gsgp, p);
14 }
15
16 struct rcutest *thread1_help(struct rcutest *p)
17 {
18   if (p)
19     assert(p->a == 42);
20   return rcu_dereference(gsgp);
21 }
22
23 void thread1(void)
24 {
25   struct rcutest *p;
26
27   p = rcu_dereference(gp);
28   p = thread1_help(p);
29   if (p)
30     assert(p->a == 43);
31 }
\end{verbatim}
}
\caption{In and Out, But Different Chains}
\label{fig:In and Out, But Different Chains}
\end{figure}

Figure~\ref{fig:In and Out, But Different Chains}
shows an example where a dependency chain enters a function
(\co{thread1_help()} on lines~16-21)
and a dependency chain leaves that same function,
but where they are different chains.

\subsection{Chain Fanning Out}
\label{sec:Chain Fanning Out}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void thread0(void)
 2 {
 3   struct rcutest *p;
 4
 5   p = (struct rcutest *)malloc(sizeof(*p));
 6   assert(p);
 7   p->a = 42;
 8   rcu_assign_pointer(gp, p);
 9 }
10
11 void
12 thread1_help1(struct rcutest *q)
13 {
14   if (q)
15     assert(q->a == 42);
16 }
17
18 void
19 thread1_help2(struct rcutest *q)
20 {
21   if (q)
22     assert(q->a != 43);
23 }
24
25 void thread1(void)
26 {
27   struct rcutest *p;
28
29   p = rcu_dereference(gp);
30   thread1_help1(p);
31   thread1_help2(p);
32 }
\end{verbatim}
}
\caption{Chain Fanning Out}
\label{fig:Chain Fanning Out}
\end{figure}

Figure~\ref{fig:Chain Fanning Out}
shows a dependency chain fanning out, courtesy of the \co{thread1()}
function's calls to \co{thread1_help1()} and \co{thread1_help2()}
on lines~30 and~31.
This is a common pattern in the Linux kernel, as it supports
abstraction of data structures, for example, allowing common RCU-protected
data structures to be aggregated into a larger RCU-protected data
structure.
In this scenario, \co{thread1_help1()} might implement one type of
RCU-protected structure and \co{thread1_help2()} might implement
another.

\subsection{Chain Fanning In}
\label{sec:Chain Fanning In}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void thread0(void)
 2 {
 3   struct rcutest *p;
 4   struct rcutest1 *p1;
 5
 6   p = (struct rcutest *)malloc(sizeof(*p));
 7   assert(p);
 8   p->a = 42;
 9   rcu_assign_pointer(gp, p);
10
11   p1 = (struct rcutest *)malloc(sizeof(*p1));
12   assert(p1);
13   p1->a = 41;
14   p1->rt->a = 42;
15   rcu_assign_pointer(g1p, p1);
16 }
17
18 void
19 thread1_help(struct rcutest *q)
20 {
21   if (q)
22     assert(q->a == 42);
23 }
24
25 void thread1(void)
26 {
27   struct rcutest *p;
28
29   p = rcu_dereference(gp);
30   thread1_help(p);
31 }
32
33 void thread2(void)
34 {
35   struct rcutest1 *p1;
36
37   p1 = rcu_dereference(g1p);
38   thread1_help(&p1->rt);
39 }
\end{verbatim}
}
\caption{Chain Fanning In}
\label{fig:Chain Fanning In}
\end{figure}

Figure~\ref{fig:Chain Fanning In}
demonstrates different dependency chains fanning into the same function,
in this case \co{thread1_help()}, from lines~29 and~37.
This fanning-in is also used to support abstraction, for example,
allowing a given implementation of an RCU-protected data structure
to be aggregated into several different data structures.

\subsection{Chain Fanning In and Out}
\label{sec:Chain Fanning In and Out}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void thread0(void)
 2 {
 3   struct rcutest *p;
 4   struct rcutest1 *p1;
 5
 6   p = (struct rcutest *)malloc(sizeof(*p));
 7   assert(p);
 8   p->a = 42;
 9   p->b = 43;
10   rcu_assign_pointer(gp, p);
11
12   p1 = (struct rcutest *)malloc(sizeof(*p1));
13   assert(p1);
14   p1->a = 41;
15   p1->rt->a = 42;
16   p1->rt->b = 43;
17   rcu_assign_pointer(g1p, p1);
18 }
19
20 void
21 thread1a_help(struct rcutest *q)
22 {
23   assert(q->a == 42);
24 }
25
26 void
27 thread1b_help(struct rcutest *q)
28 {
29   assert(q->b == 43);
30 }
31
32 void
33 thread1_help(struct rcutest *q)
34 {
35   if (q) {
36     thread1a_help(q);
37     thread1b_help(q);
38   }
39 }
40
41 void thread1(void)
42 {
43   struct rcutest *p;
44
45   p = rcu_dereference(gp);
46   thread1_help(p);
47 }
48
49 void thread2(void)
50 {
51   struct rcutest1 *p1;
52
53   p1 = rcu_dereference(g1p);
54   thread1_help(&p1->rt);
55 }
\end{verbatim}
}
\caption{Chain Fanning In and Out}
\label{fig:Chain Fanning In and Out}
\end{figure}

Figure~\ref{fig:Chain Fanning In and Out}
shows dependency chains fanning both in and out, starting
at lines~45 and~53, fanning into \co{thread1_help()}, and
fanning out again at the call to \co{thread1a_help()} on
line~36 and to \co{thread1b_help()} on line~37.
This combination permits composition of the types of abstraction
described in
Sections~\ref{sec:Chain Fanning Out}
and~\ref{sec:Chain Fanning In}.

\subsection{Conditional Compilation of Chain Endpoints}
\label{sec:Conditional Compilation of Chain Endpoints}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void thread0(void)
 2 {
 3   struct rcutest *p;
 4   struct rcutest1 *p1;
 5
 6   p = (struct rcutest *)malloc(sizeof(*p));
 7   assert(p);
 8   p->a = 42;
 9   p->b = 43;
10   rcu_assign_pointer(gp, p);
11
12   p1 = (struct rcutest *)malloc(sizeof(*p1));
13   assert(p1);
14   p1->a = 41;
15   p1->rt->a = 42;
16   p1->rt->b = 43;
17   rcu_assign_pointer(g1p, p1);
18 }
19
20 #ifdef FOO
21 void
22 thread1a_help(struct rcutest *q)
23 {
24   assert(q->a == 42);
25 }
26 #endif
27
28 void
29 thread1b_help(struct rcutest *q)
30 {
31   assert(q->b == 43);
32 }
33
34 void
35 thread1_help(struct rcutest *q)
36 {
37   if (q) {
38 #ifdef FOO
39     thread1a_help(q);
40 #endif
41     thread1b_help(q);
42   }
43 }
44
45 void thread1(void)
46 {
47   struct rcutest *p;
48
49   p = rcu_dereference(gp);
50   thread1_help(p);
51 }
52
53 void thread2(void)
54 {
55   struct rcutest1 *p1;
56
57   p1 = rcu_dereference(g1p);
58   thread1_help(&p1->rt);
59 }
\end{verbatim}
}
\caption{Conditional Compilation of Chain Endpoints}
\label{fig:Conditional Compilation of Chain Endpoints}
\end{figure}

Although the C preprocessor does not necessarily have the best reputation
among the various aspects of either C or C++, it is true that it is
always there when you need it.
Figure~\ref{fig:Conditional Compilation of Chain Endpoints}
applies conditional compilation to
Figure~\ref{fig:Chain Fanning In and Out},
so that portions of the dependency chain can come and go, depending
on the value of the C-preprocessor macro \co{FOO}.

\subsection{Handoff to Locking}
\label{sec:Handoff to Locking}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void thread0(void)
 2 {
 3   struct rcutest *p;
 4
 5   p = (struct rcutest *)malloc(sizeof(*p));
 6   assert(p);
 7   p->a = 42;
 8   assert(p->a != 43);
 9   rcu_assign_pointer(gp, p);
10 }
11
12 void thread1(void)
13 {
14   struct rcutest *p;
15
16   p = rcu_dereference(gp);
17   if (p) {
18     assert(p->a >= 42);
19     spin_lock(&p->lock);
20     p = std::kill_dependency(p);
21     p->a++;
22     spin_unlock(&p->lock);
23   }
24 }
\end{verbatim}
}
\caption{Handoff to Locking}
\label{fig:Handoff to Locking}
\end{figure}

Figure~\ref{fig:Handoff to Locking}
shows how RCU protection can hand off to other synchronization
primitives, in this case, locking.
The dependency chain starts at line~16 and continues through line~18
and~19.
However, once line~19 has completed, the code is under the protection
of \co{p->lock}, so line~20 explicitly ends the dependency chain.
The lock then protects the increment on line~21.

It is also possible to hand off protection from RCU to reference counting,
explicit memory barriers, transactional memory, and so on.

Note that the \co{std::kill_dependency()} on line~20 will typically have
no effect on code generation.

\subsection{Evaluation Criteria}
\label{sec:Evaluation Criteria}

\begin{enumerate}
\item	Ease of compilation.
\item	Ease of modification of programs.
\item	Precise specification of dependency chains.
\item	Support for cross-function dependency chains.
\item	Support for cross-compilation-unit dependency chains.
\item	Compatibility with C.
\end{enumerate}

\section{Marking Proposals}
\label{sec:Marking Proposals}

The following sections present alternative marking proposals.
Whatever proposal is chosen, implementors are encouraged to provide
a means (for example, a command-line argument) to cause the
implementation to act as if markings were placed everywhere they
could reasonably be placed.
This approach permits unmarked programs containing dependency chains
to be handled in a reasonably natural manner.

\subsection{Mark Translation Unit}
\label{sec:Mark Translation Unit}

Within the language, translation-unit marking could be accomplished by
a pragma or by a language feature that changed the way pointers are
implemented.
A compiler command-line argument could also be used, but this is of
course outside the standard.
It would be desirable for marked translation units to be able to
be linked with unmarked translation units.

This approach could be useful in cases where only a few of the translation
units contain dependency chains.
However, software-engineering considerations would likely cause many such
projects to mark all the translation units.

\subsection{Mark Range of Code}
\label{sec:Mark Range of Code}

Ranges of code could be marked by pragmas, through use of C preprocessor
symbols, or via other ad-hoc means.

\subsection{Mark Functions}
\label{sec:Mark Functions}

\subsection{Mark Objects}
\label{sec:Mark Objects}

\subsubsection{Attribute}
\label{sec:Attribute}

This approach, suggested by Clark Nelson, generalizes the
\co{[[carries_dependency]]} attribute specified in the C++11 standard
so that it applies to objects, including variables, formal parameters,
return values, and class members.
This paper further modifies this attribute so as to also restrict
it to pointer-like objects,

\subsubsection{Type Qualifier}
\label{sec:Type Qualifier}

This approach, put forward by Torvald Riegel in response to
Linus Torvalds's spirited criticisms of the current C11 and C++11
wording, introduces a new \co{value_dep_preserving} type qualifier.
Objects marked with this type qualifier carry dependencies.

\subsubsection{Object Modifier}
\label{sec:Object Modifier}

This approach uses a keyword that does not participate in type checking,
for example, a \co{_Carries_dependency} keyword.
This might be treated in a manner similar to a storage class.

\subsubsection{Template}
\label{sec:Template}

This approach, suggested off-list by JF Bastien, creates a
\co{depending_ptr}\footnote{
	Arbitrarily chosen name with no Google hits.}
template to which a pointer-like type is passed.
This approach allows implementers considerable freedom, as they can
hook into the \co{->} and \co{*} if need be.

\subsection{Mark Root/Leaf Pairs}
\label{sec:Mark Root/Leaf Pairs}

\subsubsection{Mark From Root}
\label{sec:Mark From Root}

\subsubsection{Mark From Leaves}
\label{sec:Mark From Leaves}

\subsubsection{Identify Dependency Trees}
\label{sec:Identify Dependency Trees}

\section{Evaluation}
\label{sec:Evaluation}

@@@

The most obscure member of the C11 and C++11 \co{memory_order} \co{enum}
seems to be
\co{memory_order_consume}~\cite{RichardSmith2015N4527}.
The purpose of \co{memory_order_consume} is to allow reading threads
to correctly traverse linked data structures without the need for locks,
atomic instructions, or (with the exception of DEC Alpha) memory-fence
instructions, even though new elements are being inserted into these
linked structures before, during, and after the traversal.
Without \co{memory_order_consume}, both the compiler and (again, in the case
of DEC Alpha) the CPU would be within their rights to carry out aggressive
data-speculation optimizations that would permit readers to see
pre-initialization values in the newly added data elements.
The purpose of \co{memory_order_consume} is to prevent these optimizations.

Of course, \co{memory_order_acquire} may be used as a substitute for
\co{memory_order_consume}, however doing so results in costly
explicit memory-fence instructions (or, where available, load-acquire
instructions) on weakly ordered systems such as ARM, Itanium, and
PowerPC~\cite{ARMv7A:2010,ARMv8Litmus2009,IntelItaniumMemoryOrdering2002,PowerISA2.07-2013}.
These systems enforce dependency ordering in hardware, in other words,
if the address used by one memory-reference instruction depends on the
value from a preceding load instruction, the hardware forces that
earlier load to complete before the later memory-reference instruction
commences.\footnote{
	But please note that hardware can and does take advantage
	of the as-if rule, just as compilers do.}
Similarly, if the data to be stored by a given store instruction depends
on the value from a preceding load instruction, the hardware again
forces that earlier load to complete before the later store instruction
commences.
Recent software tools for ARM and PowerPC can help explicate their
memory models~\cite{JadeAlglave2011ppcmem,Alglave:2014:HCM:2594291.2594347,PaulEMcKenney2011ppcmem,PaulEMcKenney2014weakaxiom}.
Note that strongly ordered systems like x86, IBM mainframe, and
SPARC TSO enforce dependency ordering as a side effect of the
fact that they do not reorder loads with subsequent memory references.
Therefore, \co{memory_order_consume} is beneficial on hot code paths,
removing the need for hardware ordering instructions for weakly ordered
systems and permitting additional compiler optimizations on
strongly ordered systems.

When implementing concurrent insertion-only data structures, a few of which are
found in the Linux kernel, 
\co{memory_order_consume} is all that is required.
However, most data structures also require removal of data elements.
Such removal requires that the thread removing the data element wait for all
readers to release their references to it before reclaiming that element.
The traditional way to do this is via garbage collectors (GCs), which
have been available for more than half a
century~\cite{McCarthy:1960:RFS:367177.367199}
and which are now available even for
C and C++~\cite{Boehm:2004:SEC:989393.989442}.
Another way to wait for readers is to use read-copy update
(RCU)~\cite{McKenney:2013:SDS:2483852.2483867,McKenney98},
which explicitly marks read-side regions of code and provides
primitives that wait for all pre-existing readers to complete.
RCU is gaining significant use both within the
Linux kernel~\cite{PaulEMcKenneyRCUusageRawDataPage}
and outside of it~\cite{MikeDay2013RCUqemu,MichaelDaltonPhD2009,MathieuDesnoyers2012URCU,HariKannan2009DynamicAnalysisRCU,GuillermoVigueras2012RCUCrowd}.

Despite the growing number of \co{memory_order_consume} use cases,
there are no known high-performance implementations of
\co{memory_order_consume} loads in any C11 or C++11 environments.
This situation suggests that some change is in order:  After all, if
implementations do not support the standard's \co{memory_order_consume}
facility, users
can be expected to continue to exploit whatever implementation-specific
facilities allow them to get their jobs done.
This document therefore provides a brief overview of RCU in
Section~\ref{sec:Introduction to RCU}
and surveys \co{memory_order_consume} use cases
within the Linux kernel in
Section~\ref{sec:Linux-Kernel Use Cases}.
Section~\ref{sec:Dependency Ordering in Pre-C11 Implementations}
looks at how dependency ordering is currently supported in
pre-C11 implementations,
and then
Section~\ref{sec:Dependency Ordering in C11 and C++11 Implementations}
looks at possible ways to
support those use cases in existing C11 and C++11 implementations,
followed by some thoughts on incremental paths towards official support
of these use cases in the standards.
Section~\ref{sec:Weaknesses in C11 and C++11 Dependency Ordering}
lists some weaknesses in the current C11 and C++11 specification
of dependency ordering, and finally
Section~\ref{sec:Potential Alternatives to C11 and C++11 Dependency Ordering}
outlines a few possible alternative dependency-ordering specifications.

\emph{Note: SC22/WG14 liason issue.}

\section{Introduction to RCU}
\label{sec:Introduction to RCU}

@@@

\section{Linux-Kernel Use Cases}
\label{sec:Linux-Kernel Use Cases}

Section~\ref{sec:Types of Linux-Kernel Dependency Chains}
lists types of dependency chains in the Linux kernel,
Section~\ref{sec:Operators in Linux-Kernel Dependency Chains}
lists operators used within these dependency chains,
Section~\ref{sec:Operators Terminating Linux-Kernel Dependency Chains}
lists operators that are considered to terminate dependency chains,
Section~\ref{sec:Operators Acting as Last Link in Linux-Kernel Dependency Chains}
lists operator that often act as the last link in a dependency chain,
and finally
Section~\ref{sec:Linux-Kernel Dependency Chain Length}
surveys a longer-than-average (but by no means maximal) dependency chain
that appears in the Linux kernel.

It is worth reviewing the relationship between \co{memory_order_acquire}
and \co{memory_order_consume} loads, both of which interact with
\co{memory_order_release} stores.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void new_element(struct foo **pp, int a)
 2 {
 3   struct foo *p = malloc(sizeof(*p));
 4 
 5   if (!p)
 6     abort();
 7   p->a = a;
 8   atomic_store_explicit(pp, p, memory_order_release);
 9 }
10 
11 int traverse(struct foo_head *ph)
12 {
13   int a = -1;
14   struct foo *p;
15 
16   p = atomic_load_explicit(&ph->h, memory_order_acquire);
17   while (p != NULL) {
18     a = p->a;
19     p = atomic_load_explicit(&p->n, memory_order_acquire);
20   }
21   return a;
22 }
23 \end{verbatim}
24 }
\caption{Release/Acquire Linked Structure Traversal}
\label{fig:Release/Acquire Linked Structure Traversal}
\end{figure}

A \co{memory_order_release} store is said to \emph{synchronize with}
a \co{memory_order_acquire} load if that load returns the value stored
or in some special cases, some later
value~\cite[1.10p9-1.10p10]{RichardSmith2015N4527}.
When a \co{memory_order_release} store synchronizes with a
\co{memory_order_acquire} load, any memory reference preceding the
\co{memory_order_release} store will \emph{happen before}
any memory reference following the
\co{memory_order_acquire} load~\cite[1.10p13-1.10p14]{RichardSmith2015N4527}.
This property allows a linked structure to be locklessly traversed
by using \co{memory_order_release} stores when updating pointers to
reference new data elements and by using \co{memory_order_acquire}
loads when loading pointers while locklessly traversing the data
structure, as shown in
Figure~\ref{fig:Release/Acquire Linked Structure Traversal}.

Unfortunately, a \co{memory_order_acquire} load requires expensive
special load instructions or memory-fence instructions on weakly
ordered systems such as ARM, Itanium, and PowerPC.
Furthermore, in \co{traverse()}, the address of each
\co{memory_order_acquire} load within the while loop depends on the value
of the previous \co{memory_order_acquire} load.\footnote{
	The initial load on line~16 might well depend on an earlier
	load, but for simplicity, this example assumes that the
	initial \co{foo_head} structure is statically allocated,
	and thus not subject to updates.}
Therefore, in this case, most weakly ordered systems don't really need
the special load instructions or the memory-fence instructions,
as these systems can instead rely on the hardware-enforced dependency
ordering.
On strongly ordered systems, \co{memory_order_acquire} needlessly
suppresses memory-movement compiler optimizations.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void new_element(struct foo **pp, int a)
 2 {
 3   struct foo *p = malloc(sizeof(*p));
 4 
 5   if (!p)
 6     abort();
 7   p->a = a;
 8   atomic_store_explicit(pp, p, memory_order_release);
 9 }
10 
11 int traverse(struct foo_head *ph)
12 {
13   int a = -1;
14   struct foo *p;
15 
16   p = atomic_load_explicit(&ph->h, memory_order_consume);
17   while (p != NULL) {
18     a = p->a;
19     p = atomic_load_explicit(&p->n, memory_order_consume);
20   }
21   return a;
22 }
23 \end{verbatim}
24 }
\caption{Release/Consume Linked Structure Traversal}
\label{fig:Release/Consume Linked Structure Traversal}
\end{figure}

This is the use case for \co{memory_order_consume}, which can
be substituted for \co{memory_order_acquire} in cases where
hardware dependency ordering applies.
One such case is the preceding example, and
Figure~\ref{fig:Release/Consume Linked Structure Traversal}
shows that same example recast in terms of \co{memory_order_consume}.
A \co{memory_order_release} store is \emph{dependency ordered before}
a \co{memory_order_consume} load when that load returns the value
stored, or in some special cases, some later
value~\cite[1.10p12]{RichardSmith2015N4527}.
Then, if the load \emph{carries a dependency} to some later
memory reference~\cite[1.10p11]{RichardSmith2015N4527},
any memory reference preceding the \co{memory_order_release}
store will happen before that later memory
reference~\cite[1.10p11-1.10p14]{RichardSmith2015N4527}.
This means that when there is dependency ordering,
\co{memory_order_consume} gives the same guarantees that
\co{memory_order_acquire} does, but at lower cost.

On the other hand, \co{memory_order_consume} requires the compiler
to track the carries-a-dependency relationships, with the
set of such relationships headed by a given \co{memory_order_consume}
load being called that load's \emph{dependency chains}.
It is quite possible that the complexity of implementing this
capability has thus far prevented high-quality \co{memory_order_consume}
implementations from appearing.
It is therefore worthwhile to review use of dependency chains in
practice in order to determine what types of operations typically
appear in dependency chains, which might result in guidance to
implementations or perhaps even modifications to the definition of
\co{memory_order_consume}.

\subsection{Types of Linux-Kernel Dependency Chains}
\label{sec:Types of Linux-Kernel Dependency Chains}

One goal for \co{memory_order_consume} is to implement
\co{rcu_dereference()}, which heads a Linux-kernel dependency-ordering tree.
There is a number of variants of \co{rcu_dereference()} in the
Linux kernel in order to implement the four flavors of RCU and also to enable
RCU usage diagnositics for code that is shared by readers and updaters.
These additional variants are
\co{rcu_dereference()},
\co{rcu_dereference_bh()},
\co{rcu_dereference_bh_check()},
\co{rcu_dereference_bh_check()},
\co{rcu_dereference_check()},
\co{rcu_dereference_index_check()} (now removed),
\co{rcu_dereference_protected()},
\co{rcu_dereference_raw()},
\co{rcu_dereference_sched()}, 
\co{rcu_dereference_sched_check()},
\co{srcu_dereference()}, and
\co{srcu_dereference_check()}.
Taken together, there are about 1300 uses of these functions in version 3.13
of the Linux kernel.
However, about 250 of those are \co{rcu_dereference_protected()}, which
is used only in update-side code and thus does not head up read-side
dependency chains, which leaves about 1000 uses to be inspected for
dependency-ordering usage.

\subsection{Operators in Linux-Kernel Dependency Chains}
\label{sec:Operators in Linux-Kernel Dependency Chains}

A surprisingly small fraction of the possible C operators appear in
dependency chains in the Linux kernel, namely
\co{->}, infix \co{=}, casts, prefix \co{&}, prefix \co{*}, \co{[]},
infix \co{+}, infix \co{-}, ternary \co{?:}, and infix (bitwise) \co{&}.

By far the two most common operators are the \co{->} pointer field selector
and the \co{=} assignment operator.
Enabling the carries-dependency relationship through only these two
operators would likely cover better than 90\% of the Linux-kernel use cases.

Casts, the prefix \co{*} indirection operator, and the prefix
\co{&} address-of operator are used to implement Linux's list
primitives, which translate from list pointers embedded in a
structure to the structure itself.
These operators are also used to get some of the effects of C++
subtyping in the C language.

The \co{[]} array-indexing operator, and the infix \co{+} and \co{-}
arithmetic operators are used to manipulate RCU-protected arrays,
as well as to index into arrays contained within RCU-protected structures.
RCU-protected arrays are becoming less common because they are being
converted into more complex data structures, such as trees.
However, RCU-protected structures containing arrays are still fairly common.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 struct foo {
 2   int a;
 3 };
 4 struct foo *fp;
 5 struct foo default_foo;
 6 
 7 int bar()
 8 {
 9   struct foo *p;
10 
11   p = rcu_dereference(fp);
12   return p ? p->a : default_foo.a;
13 }
\end{verbatim}
}
\caption{Default Value For RCU-Protected Pointer, Linux Kernel}
\label{fig:Default Value For RCU-Protected Pointer, Linux Kernel}
\end{figure}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 struct foo {
 2   int a;
 3 };
 4 std::atomic<foo *> fp;
 5 foo default_foo;
 6 
 7 int bar()
 8 {
 9   foo *p;
10 
11   p = fp.load(memory_order_consume);
12   return p ? std::kill_dependency(p->a) : default_foo.a;
13 }
\end{verbatim}
}
\caption{Default Value For RCU-Protected Pointer, C++11}
\label{fig:Default Value For RCU-Protected Pointer, C++11}
\end{figure}

The ternary \co{?:} if-then-else operator is used to handle default
values for RCU-protected pointers, for example, as shown in
Figure~\ref{fig:Default Value For RCU-Protected Pointer, Linux Kernel},
or in C++11 form in
Figure~\ref{fig:Default Value For RCU-Protected Pointer, C++11}.
Note that the dependency is carried only through the rightmost two
operands of \co{?:}, never through the leftmost one.

The infix \co{&} operator is used to mask low-order bits from RCU pointers.
These bits are used by some algorithms as markers.
Such markers, though not common in the Linux kernel, are well-known in
the art, with hazard pointers being but one example~\cite{MagedMichael04a}.
This operator is also sometimes used to locate the beginning of an
aligned structure, for example, if \co{p} references a field within a
data structure that is 4096 bytes in size (or smaller), and that is also
aligned to a 4096-byte boundary, then \co{p & ~0xfff} will, with the
addition of appropriate casting, produce a pointer to the beginning of
the structure.
Note that it is expected that both operands of infix \co{&} are expected
to have some non-zero bits, because otherwise a \co{NULL} pointer will
result, and \co{NULL} pointers cannot
reasonably be said to carry much of anything, let alone a dependency.

Although I did not find any infix \co{|} operators in my census of
Linux-kernel dependency chains,
symmetry considerations argue for also including it, for example, for
read-side pointer tagging, or, for another example, locating the beginning
of the next in an array of aligned structures.
Presumably both of the operands of infix \co{|} must have at least one
zero bit.

To recap, the operators appearing in Linux-kernel dependency chains are:
\co{->}, infix \co{=}, casts, prefix \co{&}, prefix \co{*}, \co{[]},
infix \co{+}, infix \co{-}, ternary \co{?:}, infix (bitwise) \co{&},
and probably also \co{|}.

\subsection{Operators Terminating Linux-Kernel Dependency Chains}
\label{sec:Operators Terminating Linux-Kernel Dependency Chains}

Although C++11 has the \co{std::kill_dependency()} function to terminate
a dependency chain, no such function exists in the Linux kernel.
Instead, Linux-kernel dependency chains are judged to have terminated
upon exit from the outermost RCU read-side critical section,\footnote{
	The beginning of a given RCU read-side critical section is marked
	with \co{rcu_read_lock()}, \co{rcu_read_lock_bh()},
	\co{rcu_read_lock_sched()}, or \co{srcu_read_lock()},
	and the end by the corresponding primitive from the list
	\co{rcu_read_unlock()}, \co{rcu_read_unlock_bh()},
	\co{rcu_read_unlock_sched()}, or \co{srcu_read_unlock()}.
	There is currently no C++11 counterpart for an RCU read-side
	critical section.}
when existence guarantees are handed off from RCU to some other
synchronization mechanism (usually locking or reference counting),
or when the variable carrying the dependency goes out of scope.

That said, it is possible to analyze Linux-kernel dependency chains
to see what part of the chain is actually required by the algorithm
in question.
We can therefore define the \emph{essential subset} of a dependency chain
to be that subset within which ordering is required by the algorithm.
In the 3.13 version of the Linux kernel, the following operators
always mark the end of the essential subset of a dependency chain:
\co{()}, \co{!}, \co{==}, \co{!=}, \co{&&}, \co{||}, infix \co{*}, \co{/},
and \co{\%}.

The postfix \co{()} function-invocation operator is an interesting special
case in the Linux kernel.
In theory, RCU could be used to protect JITed function bodies, but in
current practice RCU is instead used to wait for all pre-existing
callers to the function referenced by the previous pointer.
The functions are all compiled into the kernel, and the dependency
chains are therefore irrelevant to the \co{()} operator.
Hence, in version 3.13 of the Linux kernel, the \co{()} operator
marks the end of the essential subset of any dependency chain that
it resides in.

The \co{!}, \co{==}, \co{!=}, \co{&&}, and \co{||} operators are
used exclusively in ``if'' statements to make control-flow decisions,
and therefore also mark the end of the essential subset of any
dependency chains that they reside in.
In theory, these relational and boolean operators could be used to
form array indexes, but in practice the Linux kernel does not yet
do this in RCU dependency chains, and furthermore, as of version 4.2
of the Linux kernel, integers are no longer allowed to carry dependencies
except in very restricted situations.
The other relational operators (\co{>}, \co{<}, \co{>=}, and \co{<=})
should probably also be added to this list.

The infix \co{*}, \co{/}, and \co{\%} arithmetic operators could potentially
be used for construct array addresses, but they are not yet used that
way in the Linux kernel.
Instead, they are used to do computation on values fetched as the
last operation in an essential subset of a dependency chain.

In short, in the current Linux kernel,
\co{()}, \co{!}, \co{==}, \co{!=}, \co{&&}, \co{||}, infix \co{*}, \co{/},
and \co{\%} all mark the end of the essential subset of a dependency
chain.
That said, there is potential for them to be used as part of the
essential subset of dependency changes in future versions of the
Linux kernel.
And the same is of course true of the remaining C-language operators,
which did not appear within any of the dependency chains in version 3.13
of the Linux kernel.

\subsection{Operators Acting as Last Link in Linux-Kernel Dependency Chains}
\label{sec:Operators Acting as Last Link in Linux-Kernel Dependency Chains}

Although the \co{->} operator is frequently used as part of a
Linux-kernel dependency chain, it often is intended to be the last link
in that chain.
Therefore, the uses cases for the \co{->} operator deserve special mention.

The first use case involves fetching non-pointer data from an RCU-protected
data structure.
For example, in the DRDB subsystem in Linux, \co{->} is used to fetch
a timeout value.
This code requires that dependency ordering apply to this fetch, but
it does not require a dependency chain extending beyond that point.
This sort of case would require a \co{std::kill_dependency()}
for implementations based on the C++11 and C11 standards.

The second use case involves linked data structures where an RCU update
might be applied on any pointer in the chain, for example, the standard
Linux-kernel linked list.
The \co{->} operator provides dependency ordering for the fetch of the
\co{->next} pointer, but that fetch must itself be a \co{memory_order_consume}
load in order to provide the required dependency ordering for the fields
in the next structure in the list.
Thus, a linked-list traversal consists of a series of back-to-back
non-overlapping dependency chains.

These two use cases raise the question of whether a dependency chain
can continue beyond a \co{->} operator.
The answer is ``yes'', and this occurs when a linked structure is
made visible to RCU readers as a unit.
For example, consider a linked list where each list element links to
a constant binary search tree.
If this tree is in place when the element is added to the list, then
a \co{memory_order_consume} load is needed only when fetching the
pointer to the element.
The dependency chain headed by this fetch suffices to order accesses
to the binary search tree.

These cases need to be differentiated.
The third use case appears to be the least frequent, which suggests
that the \co{->} operator (or a sequence of \co{->} operators)
always be the last link of a dependency
chain.
Another alternative is to differentiate on type, so that only pointer-like
types (including \co{intptr_t} and \co{uintptr_t}) carry dependencies.

\subsection{Linux-Kernel Dependency Chain Length}
\label{sec:Linux-Kernel Dependency Chain Length}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void new_element(struct foo **pp, int a)
 2 {
 3   struct foo *p = malloc(sizeof(*p));
 4 
 5   if (!p)
 6     abort();
 7   p->a = a;
 8   atomic_store_explicit(pp, p, memory_order_release);
 9 }
10 
11 int traverse(struct foo_head *ph)
12 {
13   int a = -1;
14   struct foo *p;
15 
16   p = atomic_load_explicit(&field_dep(ph, h),
17                            memory_order_consume);
18   while (p != NULL) {
19     a = field_dep(p, a);
20     p = atomic_load_explicit(&field_dep(p, n),
21                              memory_order_consume);
22   }
23   return a;
24 }
\end{verbatim}
}
\caption{Decorated Linked Structure Traversal}
\label{fig:Decorated Linked Structure Traversal}
\end{figure}

Many Linux-kernel dependency chains are very short and contained,
with a fair number living within the confines of a single C statement.
If there were only a few short dependency chains in the Linux kernel,
one could imagine decorating all the operators in each dependency
chain, for example, replacing the \co{->} operator with something
like the mythical \co{field_dep()} operator shown on lines~16,
19, and~20 of
Figure~\ref{fig:Decorated Linked Structure Traversal}.

However, there are a great many dependency chains that extend across
multiple functions.
One relatively modest example is in the Linux network stack, in
the \co{arp_process()} function.
This dependency chain extends as follows, with deeper nesting indicating
deeper function-call levels:

\begin{itemize}
\item	The \co{arp_process()} function invokes \co{__in_dev_get_rcu()},
	which returns an RCU-protected pointer.
	The head of the dependency chain is therefore within
	the \co{__in_dev_get_rcu()} function.
\item	The \co{arp_process()} function invokes the following macros
	and functions:
	\begin{itemize}
	\item	\co{IN_DEV_ROUTE_LOCALNET()}, which expands to
		the \co{ipv4_devconf_get()} function.
	\item	\co{arp_ignore()}, which in turn calls:
		\begin{itemize}
		\item	\co{IN_DEV_ARP_IGNORE()}, which expands to the
			\co{ipv4_devconf_get()} function.
		\item	\co{inet_confirm_addr()}, which calls:
			\begin{itemize}
			\item	\co{dev_net()}, which in turn calls
				\co{read_pnet()}.
			\end{itemize}
		\end{itemize}
	\item	\co{IN_DEV_ARPFILTER()}, which expands to
		\co{ipv4_devconf_get()}.
	\item	\co{IN_DEV_CONF_GET()}, which also expands to
		\co{ipv4_devconf_get()}.
	\item	\co{arp_fwd_proxy()}, which calls:
		\begin{itemize}
		\item	\co{IN_DEV_PROXY_ARP()}, which expands to
			\co{ipv4_devconf_get()}.
		\item	\co{IN_DEV_MEDIUM_ID()}, which also expands to
			\co{ipv4_devconf_get()}.
		\end{itemize}
	\item	\co{arp_fwd_pvlan()}, which calls:
		\begin{itemize}
		\item	\co{IN_DEV_PROXY_ARP_PVLAN()}, which expands to
			\co{ipv4_devconf_get()}.
		\end{itemize}
	\item	\co{pneigh_enqueue()}.
	\end{itemize}
\end{itemize}

Again, although a great many dependency chains in the Linux kernel
are quite short, there are quite a few that spread both widely and deeply.
We therefore cannot expect Linux kernel hackers to look fondly on
any mechanism that requires them to decorate each and every operator
in each and every dependency chain as was shown in
Figure~\ref{fig:Decorated Linked Structure Traversal}.
In fact, even \co{std::kill_dependency()} will likely be
an extremely difficult sell.

\section{Dependency Ordering in Pre-C11 Implementations}
\label{sec:Dependency Ordering in Pre-C11 Implementations}

Pre-C11 implementations of the C language do not have any formal
notion of dependency ordering, but these implementations are
nevertheless used to build the Linux kernel---and most likely
all other software using RCU.
This section lays out a few straightforward rules for both
implementers (Section~\ref{sec:Rules for C-Language Implementers})
and users of these pre-C11 C-language implementations
(Section~\ref{sec:Rules for C-Language RCU Users}).

\subsection{Rules for C-Language RCU Users}
\label{sec:Rules for C-Language RCU Users}

The rules for C-language RCU users have evolved over time, so this
section will present them in reverse chronological order.

\subsubsection{Rules for 2014 GCC Implementations}
\label{sec:Rules for 2014 GCC Implementations}

The primary rule for developers implementing RCU-based algorithms
is to avoid letting the compiler determing the value of any variable
in any dependency chain.
This primary rule implies a number of secondary rules:

\begin{enumerate}
\item	Use only intrinsic operators on basic types.
	If you are making use of C++ template metaprogramming or
	operator overloading, more elaborate rules apply, and those
	rules are outside the scope of this document.
\item	Use a volatile load to head the dependency chain.
	This is necessary to avoid the compiler repeating
	the load or making use of (possibly erroneous) prior
	knowledge of the contents of the memory location,
	each of which can break dependency chains.
\item	Avoid use of single-element RCU-protected arrays.
	The compiler is within its right to assume that the
	value of an index into such an array must necessarily evaluate
	to zero.
	The compiler could then substitute the constant zero for
	the computation, breaking the dependency chain and introducing
	misordering.
	That said, recent experience indicates that it is even better
	to simply avoid carrying dependencies through integer types.
\item	Avoid cancellation when using the \co{+} and \co{-} infix
	arithmetic operators.
	For example, for a given variable $x$, avoid $(x-x)$.
	The compiler is within its rights to substitute zero for any
	such cancellation, breaking the dependency chain and again
	introducing misordering.
	Similar arithmetic pitfalls must be avoided if the
	infix \co{*}, \co{/}, or \co{\%} operators appear in
	the essential subset of a dependency chain.
	Again, recent experience indicates that it is even better
	to make sure that one of the operands of these arithmetic
	operators is a pointer-like type.
\item	Avoid all-zero operands to the bitwise \co{&} operator, and similarly
	avoid all-ones operands to the bitwise \co{|} operator.
	If the compiler is able to deduce the value of such operands,
	it is within its rights to substitute the corresponding constant
	for the bitwise operation.
	Once again, this breaks the dependency chain, introducing
	misordering.

	Please note that single-bit operands to bitwise \co{&} can
	be dangerous because the compiler requires only a small
	amount of additional information to deduce the exact value,
	which could again result in constant substitution.
	Operands to bitwise \co{|} that have only one zero bit are
	similarly dangerous.

\item	If you are using RCU to protect JITed functions, so that the
	\co{()} function-invocation operator is a member of the
	essential subset of the dependency tree, you may need to
	interact directly with the hardware to flush instruction
	caches.
	This issue arises on some systems when a newly JITed function
	is using the same memory that was used by an earlier JITed
	function.
\item	Do not use the boolean \co{&&} and \co{||}
	operators in essential dependency chains.
	The reason for this prohibition is that
	they are often compiled using branches.
	Weak-memory machines such as ARM or PowerPC order stores after
	such branches, but can speculate loads, which can break
	data dependency chains.
\item	Do not use relational operators (\co{==}, \co{!=}, \co{>}, \co{>=},
	\co{<}, or \co{<=}) in the essential subset of a
	dependency chain.
	The reason for this prohibition is that, as for boolean operators,
	relational operators are often compiled using branches.
	Weak-memory machines such as ARM or PowerPC order stores after
	such branches, but can speculate loads, which can break
	dependency chains.
\item	Be very careful about comparing pointers in the essential subset
	of a dependency chain.
	\label{listitem:Dependency Chain Pointer Comparison Hazards}
	As Linus Torvalds explained, if the two pointers are equal,
	the compiler could substitute the
	pointer you are comparing against for the pointer in the
	essential subset of the dependency chain.
	On ARM and Power hardware, it might be that only the original
	value carried a hardware dependency, so this substitution would
	break the chain, in turn permitting misordering.
	Such comparisons are OK in the following cases:
	\begin{enumerate}
	\item	The pointer references memory
		that was initialized at boot time, or otherwise long enough
		ago that readers cannot still have pre-initialized data
		cached.
		Examples include module-init time for module code,
		before kthread creation for code running in a kthread,
		while the update-side lock is held, and so on.
	\item	The pointer is never dereferenced after being compared.
		This exception applies when comparing against the
		\co{NULL} pointer or when scanning RCU-protected
		circular linked lists.
	\item	The pointer being compared against is part of the
		essential subset of a dependency chain.
		This can be a different dependency chain, but \emph{only}
		as long as that chain stems from a pointer that was modified
		after any initialization of interest.
		This exception can apply when carrying out RCU-protected
		traversals from different entry points that converged
		on the same data structure.
	\item	The pointer being compared against is fetched using
		\co{rcu_access_pointer()} and all subsequent
		dereferences are stores.
	\item	The pointers compared not-equal \emph{and} the compiler
		does not have enough information to deduce the value
		of the pointer.
		(For example, if the compiler can see that the pointer
		will only ever take on one of two values, then it
		will be able to deduce the exact value based on a not-equals
		comparison.)
	\end{enumerate}
	The same issue arises when a sequence of inequality comparison
	operators narrow to a single value.
\item	Disable any value-speculation optimizations that your compiler
	might provide, especially if you are making use of feedback-based
	optimizations that take data collected from prior runs.
\end{enumerate}

\subsubsection{Rules for 2003 GCC Implementations}
\label{sec:Rules for 2003 GCC Implementations}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 struct foo {
 2   int a;
 3 };
 4 struct foo *fp;
 5 struct foo default_foo;
 6 
 7 int bar()
 8 {
 9   struct foo *p;
10 
11   p = fp;
12   smp_read_barrier_depends();
13   return p ? p->a : default_foo.a;
14 }
\end{verbatim}
}
\caption{Default Value For RCU-Protected Pointer, Old Linux Kernel}
\label{fig:Default Value For RCU-Protected Pointer, Old Linux Kernel}
\end{figure}

Prior to the 2.6.9 version of the Linux kernel, there was neither
\co{rcu_dereference()} nor \co{rcu_assign_pointer()}.
Instead, explicit memory barriers were used,
\co{smp_read_barrier_depends()} by readers and
\co{smp_wmb()} by updaters.
For example, the code shown for current Linux kernels in
Figure~\ref{fig:Default Value For RCU-Protected Pointer, Linux Kernel}
would be as shown in
Figure~\ref{fig:Default Value For RCU-Protected Pointer, Old Linux Kernel}
for 2.6.8 and earlier versions of the Linux kernel.
A similar transformation relates the older use of \co{smp_wmb()} and
the more recent use of \co{rcu_assign_pointer()}.

This older API was clearly much more vulnerable to compiler optimizations
than is the current API, but the real motivation for this change was
readability and maintainability, as can be seen from
the commit log for the mid-2004 patch introducing \co{rcu_dereference()}:

\begin{quote}
This patch introduced an \co{rcu_dereference()} macro that replaces most
uses of \co{smp_read_barrier_depends()}.  The new macro has the advantage
of explicitly documenting which pointers are protected by RCU -- in
contrast, it is sometimes difficult to figure out which pointer is
being protected by a given \co{smp_read_barrier_depends()} call.
\end{quote}

The commit log for the mid-2004 patch introducing \co{rcu_assign_pointer()}
justifies the change in terms of eliminating hard-to-use
explicit memory barriers:

\begin{quote}
Attached is a patch that adds an \co{rcu_assign_pointer()} that allows
a number of explicit \co{smp_wmb()} memory barriers to be dispensed with,
improving readability.
\end{quote}

The importance of suppressing compiler optimizations did not become
apparent until much later.
In fact, a volatile cast was not added to the implementation of
\co{rcu_dereference()} until 2.6.24 in early 2008.

\subsubsection{Rules for 1990s Sequent C Implementations}
\label{sec:Rules for Sequent C Implementations}

1990s systems featured far slower CPUs and much less memory that is
commonly provisioned today, and the compilers were correspondingly
less sophisticated.
Therefore, at that time, a simple C-language field selector was used
instead of any sort of \co{rcu_dereference()} or
\co{memory_order_consume} operation.
Not only was there no volatile cast, there also was nothing resembling
\co{smp_read_barrier_depends()}.
The lack of \co{smp_read_barrier_depends()} is not too surprising, given
that DYNIX/ptx did not run on DEC Alpha.

This approach was nevertheless quite reliable because the use cases
within the DYNIX/ptx kernel were both few and straightforward, and
provided little or no opportunity for optimizations that might break
dependency chains.

\subsection{Rules for C-Language Implementers}
\label{sec:Rules for C-Language Implementers}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void new_element(struct foo **pp, int a)
 2 {
 3   struct foo *p = malloc(sizeof(*p));
 4 
 5   if (!p)
 6     abort();
 7   p->a = a;
 8   rcu_assign_pointer(pp, p);
 9 }
10 
11 int traverse(struct foo_head *ph)
12 {
13   int a = -1;
14   struct foo *p;
15 
16   p = rcu_dereference(&ph->h);
17   while (p != NULL) {
18     if (p == (struct foo *)0xbadfab1e)
19       a = ((struct foo *)0xbadfab1e)->a;
20     else
21       a = p->a;
22     p = rcu_dereference(&p->n);
23   }
24   return a;
25 }
\end{verbatim}
}
\caption{Dangerous Optimizations: Hardware Branch Predictions}
\label{fig:Dangerous Optimizations: Hardware Branch Predictions}
\end{figure}

The main rule for C-language implementers is to avoid any sort of
value speculation, or, at the very least, provide means for the user
to disable such speculation.
An example of a value-speculation optimization that can be carried
out with the help of hardware branch prediction is shown in
Figure~\ref{fig:Dangerous Optimizations: Hardware Branch Predictions},
which is an optimized version of the code in
Figure~\ref{fig:Release/Consume Linked Structure Traversal}.
This sort of transformation might result from feedback-directed
optimization, where profiling runs determined that the value
loaded from \co{ph} was almost alway \co{0xbadfab1e}.
Although this transformation is correct in a single-threaded
environment, in a concurrent environment, nothing stops the compiler
or the CPU from speculating the load on line~19 before it executes the
\co{rcu_dereference()} on line~16, which could result in line~19 executing
before the corresponding store on line~7, resulting in a garbage value
in variable \co{a}.\footnote{
	Kudos to Olivier Giroux for pointing out use of branch
	prediction to enable value speculation.}

There \emph{are} some situations where this sort of optimization would be
safe, including:

\begin{enumerate}
\item	The value speculated is a numeric value rather than a pointer,
	so that if the guess proves correct after the fact, the computation
	will be appropriate after the fact.
\item	The value speculated is a pointer to invariant data, then
	reasonable values will be produced by dereferencing, even if the
	guess proves to have been correct only after the fact.
\item	As above, but where any updates result in data that produces
	appropriate computations at any and all phases of the update.
\end{enumerate}

However, this list does not contain the general case of
\co{memory_order_consume} loads.

Pure hardware implementations of value speculation can avoid this problem
because they monitor cache-coherence protocol events that would result
from some other CPU invalidating the guess.

In short, compiler writers must provide means to disable all forms of
value speculation, unless the speculation is accompanied by some means
of detecting the race condition that
Figure~\ref{fig:Dangerous Optimizations: Hardware Branch Predictions}
is subject to.

\emph{Are there other dependency-breaking optimizations that should be
called out separately?}

\section{Dependency Ordering in C11 and C++11 Implementations}
\label{sec:Dependency Ordering in C11 and C++11 Implementations}

The simplest way to avoid dependency-ordering issues is to strengthen all
\co{memory_order_consume} operations to \co{memory_order_acquire}.
This functions correctly, but may result in unacceptable performance
due to memory-barrier instructions on weakly ordered systems such
as ARM and PowerPC,\footnote{
	From a Linux-kernel community viewpoint, that should read
	``\emph{will} result in unacceptable performance''.}
and may further unnecessarily suppress
code-motion optimizations.

Another straightforward approach is to avoid value speculation and
other dependency-breaking optimizations.
This might result in missed opportunities for optimization, but avoids
any need for dependency-chain annotations and also all issues that might
otherwise arise from use of dependency-breaking optimizations.
This approach is fully compatible with the Linux kernel community's
current approach to dependency chains.
Unfortunately, there are any number of valuable optimizations that
break dependency chains, so this approach seems impractical.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 int a(struct foo *p [[carries_dependency]])
 2 {
 3   return std::kill_dependency(p->a != 0);
 4 }
 5 
 6 int b(int x)
 7 {
 8   return x;
 9 }
10 
11 foo *c()
12 {
13   return fp.load(memory_order_consume);
14   /* return rcu_dereference(fp) in Linux kernel. */
15 }
16 
17 int d()
18 {
19   int a;
20   foo *p;
21 
22   rcu_read_lock();
23   p = c();
24   a = p->a;
25   rcu_read_unlock();
26   return a;
27 }
\end{verbatim}
}
\caption{Example Functions for Dependency Ordering, Part 1}
\label{fig:Example Functions for Dependency Ordering, Part 1}
\end{figure}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 [[carries_dependency]] struct foo *e()
 2 {
 3   return fp.load(memory_order_consume);
 4   /* return rcu_dereference(fp) in Linux kernel. */
 5 }
 6 
 7 int f()
 8 {
 9   int a;
10   foo *p;
11 
12   rcu_read_lock();
13   p = e();
14   a = p->a;
15   rcu_read_unlock();
16   return std::kill_dependency(a);
17 }
18 
19 int g()
20 {
21   int a;
22   foo *p;
23 
24   rcu_read_lock();
25   p = e();
26   a = p->a;
27   rcu_read_unlock();
28   return b(a);
29 }
\end{verbatim}
}
\caption{Example Functions for Dependency Ordering, Part 2}
\label{fig:Example Functions for Dependency Ordering, Part 2}
\end{figure}

A third approach is to avoid value speculation and other dependency-breaking
optimizations in any function containing either a \co{memory_order_consume}
load or a \co{[[carries_dependency]]} attribute.
For example, the hardware-branch-predition optimization shown in
Figure~\ref{fig:Dangerous Optimizations: Hardware Branch Predictions}
would be prohibited in such functions, as would cancellation optimizations
such as optimizing \co{a = b + c - c} into \co{a = b}.
This too can result in missed opportunities for optimization, though
very probably many fewer than the previous approach.
This approach can also result in issues due to dependency-breaking
optimizations in functions lacking \co{[[carries_dependency]]} attributes,
for example, function \co{d()} in
Figure~\ref{fig:Example Functions for Dependency Ordering, Part 1}.
It can also result in spurious memory-barrier instructions when
a dependency chain goes out of scope, for example, with the
\co{return} statement of function \co{g()} in
Figure~\ref{fig:Example Functions for Dependency Ordering, Part 2}.

A fourth approach is to add a compile-time operation corresponding to
the beginning and end of RCU read-side critical section.
These would need to be evaluated at compile time, taking into account
the fact that these critical sections can nest and can be conditionally
entered and exited.
Note that the exit from an outermost RCU read-side critical section
should imply a \co{std::kill_dependency()} operation on each
variable that is live at that point in the code.\footnote{
	What if a given \co{rcu_read_unlock()} sometimes marked the
	end of an outermost RCU read-side critical section, but other
	times was nested in some other RCU read-side critical section?
	In that case, there should be no \co{std::kill_dependency()}.}
Although it is probably impossible to precisely determine the bounds
of a given RCU read-side critical section in the general case,
conservative approaches that might overestimate the extent of
a given section should be acceptable in almost all cases.
This approach would make functions \co{c()} and \co{d()} in
Figure~\ref{fig:Example Functions for Dependency Ordering, Part 1}
handle dependency chains in a natural manner, but avoiding
whole-program analysis would require something similar to the
\co{[[carries_dependency]]} annotations called out in the
C11 and C++11 standards.

A fifth approach would be to require that all operations on the
essential subset of any dependency chain be annotated.
This would greatly ease implementation, but would not be likely
to be accepted by the Linux kernel community.

A sixth approach is to track dependencies as called out in the
C11 and C++11 standards.
However, instead of emitting a memory-barrier
instruction when a dependency chain flows into or out of a function
without the benefit of \co{[[carries_dependency]]}, insert an
implicit \co{std::kill_dependency()} invocation.
Implementation should also optionally issue a diagnostic in this case.
The motivation for this approach is that it is expected that many
more \co{kill_dependencies()} than \co{[[carries_dependency]]} would
be required to convert the Linux kernel's RCU code to C11.
In the example in
Figure~\ref{fig:Example Functions for Dependency Ordering, Part 2},
this approach would allow function \co{g()} to avoid emitting an
unnecessary memory-barrier instruction, but without function \co{f()}'s
explicit \co{std::kill_dependency()}.
Both functions are in
Figure~\ref{fig:Example Functions for Dependency Ordering, Part 2}.

A seventh and final approach is to track dependencies as called out in
in the C11 and C++11 standards.
With this approach, functions \co{e()} and \co{f()} properly
preserve the required amount of dependency ordering.

\section{Weaknesses in C11 and C++11 Dependency Ordering}
\label{sec:Weaknesses in C11 and C++11 Dependency Ordering}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 p = atomic_load_explicit(gp, memory_order_consume);
 2 if (p == ptr_a)
 3   a = p->special_a;
 4 else
 5   a = p->normal_a;
\end{verbatim}
}
\caption{Dependency-Ordering Value-Narrowing Hazard}
\label{fig:Dependency-Ordering Value-Narrowing Hazard}
\end{figure}

Experience has shown several weaknesses in the dependency ordering
specified in the C11 and C++11 standards:

\begin{enumerate}
\item	The C11 standard does not provide attributes, and in particular,
	does not provide the \co{[[carries_dependency]]} attribute.
	This prevents the developer from specifying that a given
	dependency chain passes into or out of a given function.
	The usual C-language response to this situation is to introduce
	a new keyword.
\item	The implementation complexity of the dependency-chain tracking
	required by both standard can be quite onerous on the one hand,
	and the overhead of unconditionally promoting \co{memory_order_consume}
	loads to \co{memory_order_acquire} can be excessive on
	weakly ordered implementations on the other.
	There is therefore no easy way out for a \co{memory_order_consume}
	implementation on a weakly ordered system.
\item	The function-level granularity of \co{[[carries_dependency]]}
	seems too coarse.
	One problem is that points-to analysis is non-trivial, so that
	compilers are likely to have difficulty determining whether or
	not a given pointer carries a dependency.
	For example, the current wording of the standard (intentionally!)
	does not disallow dependency chaining through stores and loads.
	Therefore,
	if a dependency-carrying value might ever be written to a
	given variable,
	an implementation might reasonably assume that
	\emph{any} load from that variable must be assumed
	to carry a dependency.
\item	The rules set out in the standard~\cite[1.10p11]{RichardSmith2015N4527}
	do not align well with the rules that developers must currently
	adhere to in order to maintain dependency chains when using
	pre-C11 and pre-C++11 compilers
	(see Section~\ref{sec:Rules for C-Language RCU Users}).
	For example, the standard requires \co{(x-x)} to carry a dependency,
	and providing this guarantee would at the very least require the
	compiler to also turn off optimizations that remove \co{(x-x)}
	(and similar patterns) if \co{x} might possibly be carrying a
	dependency.
	For another example, consider the value-speculation-like code
	shown in
	Figure~\ref{fig:Dependency-Ordering Value-Narrowing Hazard}
	that is sometimes written by developers, and that was
	described in
	bullet~\ref{listitem:Dependency Chain Pointer Comparison Hazards}
	of Section~\ref{sec:Rules for C-Language RCU Users}.
	In this example, the standard requires dependency ordering
	between the \co{memory_order_consume} load on line~1 and
	the subsequent dereference on line~3, but a typical compiler
	would not be expected to differentiate between these two
	apparently identical values.
	These two examples show that a compiler would need to detect
	and carefully handle these cases either by artificially inserting
	dependencies, omitting optimizations, differentiating between
	apparently identical values, or even by emitting
	\co{memory_order_acquire} fences.
\item	The whole point of \co{memory_order_consume} and the resulting
	dependency chains is to allow developers to optimize their code.
	Such optimization attempts can be completely defeated by
	the \co{memory_order_acquire} fences that the standard currently
	requires when a dependency chain goes out of scope without
	the benefit of a \co{[[carries_dependency]]} attribute.
	Preventing the compiler from emitting these fences requires
	liberal use of \co{std::kill_dependency()}, which clutters code,
	requires large developer effort, and further requires that
	the developer know quite a bit about which code patterns a
	given version of a given compiler can optimize (thus avoiding
	needless fences) and which it cannot (thus requiring manual
	insertion of \co{std::kill_dependency()}.
\end{enumerate}

As of this writing, no known implementations fully support
C11 or C++11 dependency ordering.

It is worth asking why Paul didn't anticipate these weaknesses.
There are several reasons for this:

\begin{enumerate}
\item	Compiler optimizations have become more aggressive over the
	eight years since Paul started working on standardization.
\item	New dependency-ordering use cases have arisen during that
	same time, in particular, there are longer dependency chains
	and more of them, including dependency chains spanning
	multiple compilation units.
\item	The number of dependency chains has increased by more than
	an order of magnitude during that time, so that changes
	in code style can be expected to face a commeasurate increase
	in resistance from the Linux kernel community -- unless those
	changes bring some tangible benefit.
\end{enumerate}

With that, let's look at some potential alternatives to
dependency ordering as defined in the C11 and C++11 standards.

\section{Potential Alternatives to C11 and C++11 Dependency Ordering}
\label{sec:Potential Alternatives to C11 and C++11 Dependency Ordering}

Given the weaknesses in the current standard's specification of
dependency ordering, it is quite reasonable to consider alternatives.
To this end,
Section~\ref{sec:Revising C11 and C++11 Dependency-Ordering Definition}
discusses ease-of-use issues involved with revisions to the
C11 and C++11 definitions of dependency ordering,
Section~\ref{sec:Type-Based Designation of Dependency Chains With Restrictions}
enlists help from the type system, but also imposes value restrictions
(thus revising the C11 and C++11 semantics for dependencies),
Section~\ref{sec:Type-Based Designation of Dependency Chains}
enlists help from the type system without the value restrictions,
and
Section~\ref{sec:Whole-Program Option} describes a whole-program approach
to dependency chains (also revising the C11 and C++11 semantics for
dependencies).
Section~\ref{sec:Local-Variable Restriction}
describes a post-Rapperswil proposal that dependency chains be
restricted to function-scope local variables and temporaries, and
Section~\ref{sec:Mark Dependency-Carrying Local Variables}
describes a second post-Rapperswil proposal that the
\co{[[carries_dependency]]} attribute be used to label local-scope
variables that carry dependencies.
Section~\ref{sec:Explicitly Tail-Marked Dependency Chains}
describes a proposal discussed verbally at Rapperswil that explicitly
marks the tails of dependency chains.
Section~\ref{sec:Explicitly Head-Marked Dependency Chains}
describes the inverse, namely marking the heads of dependency chains.
Section~\ref{sec:Restricted Dependency Chains}
describes an approach that avoids marking by sharply restricting the
number and type of operations permitted in dependency chains.
Each approach appears to have advantages and disadvantages,
so it is hoped that further discussion will either help settle on
one of these alternatives or generate something better.
To help initiate this discussion,
Section~\ref{sec:Storage Class} uses a new \co{_Carries_dependency}
storage class to mark objects that carry dependencies.
Section~\ref{sec:Evaluation}
provides an initial comparative evaluation.

\subsection{Revising C11 and C++11 Dependency-Ordering Definition}
\label{sec:Revising C11 and C++11 Dependency-Ordering Definition}

The following sections each describe a proposed revision of
the dependency-ordering definition from that in the current
C11 and C++11 standards.
In many of these proposals, developers are required to follow an
additional rule in
order to be able to rely on dependency ordering:
Subsequent execution must not lead to a situation where there is only
one possible value for the variable that is intended to carry the
dependency.\footnote{
	This restricted notion of dependence is sometimes called
	\emph{semantic dependence}, and the value at the end of
	a dependence chain that does not represent a semantic
	dependence is sometimes said to be \emph{independent}
	of the value at the head of the dependency chain.}
This is shown in
Figure~\ref{fig:Single-Value Variables and Dependency Ordering},
where the compiler is permitted to break dependency ordering on
line~6 because it knows that the value of \co{p} is equal to that
of \co{q}, which means that it could substitute the latter value
from the former, which would break dependency ordering.
In short, a dependency chain breaks if it comes to a point where only
a single value is possible, regardless of the value of the
\co{memory_order_consume} load heading up the chain.
At first glance, this additional rule could be quite difficult to live with,
as dependency ordering could come and go depending on small details of
code far away from that point in the dependency chain.

However, a review of the Linux-kernel operators in
Section~\ref{sec:Operators in Linux-Kernel Dependency Chains}
shows that the most commonly used operators act identically under
both definitions.
The problem-free operators include
\co{->}, infix \co{=}, casts, prefix \co{&}, prefix \co{*}, and
ternary \co{?:}.

One example of a potentially troublesome operator, namely \co{==}, is shown in
Figure~\ref{fig:Single-Value Variables and Dependency Ordering},
where line~6 breaks dependency ordering because the value of
\co{p} is known to be equal to that of \co{q}, which is not part
of a dependency chain.
This example could be addressed through careful diagnostic design
coupled with appropriate coding standards.
For example, the compiler could emit a warning on line~6, but remain
silent for the equivalent line substituting \co{q} for \co{p},
namely, \co{do_something_with(q->a)}.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 int my_array[MY_ARRAY_SIZE];
 2 
 3 i = atomic_load_explicit(gi, memory_order_consume);
 4 r1 = my_array[i];
\end{verbatim}
}
\caption{Single-Element Arrays and Dependency Ordering}
\label{fig:Single-Element Arrays and Dependency Ordering}
\end{figure}

Another example is the use of postfix \co{[]} that is shown in
Figure~\ref{fig:Single-Element Arrays and Dependency Ordering}.
If this code fragment was compiled with \co{MY_ARRAY_SIZE} equal to
one, there is no dependency ordering between lines~3 and~4,
but that same code fragment compiled with \co{MY_ARRAY_SIZE} equal to
two or greater \emph{would} be dependency-ordered.
Here a diagnostic for single-element arrays might prove useful,
and such a diagnostic can easily be supplied in this case using \co{#if}
and \co{#error}.
Or, better yet, don't carry dependencies through through integers
for use as array indexes.

In the Linux kernel, infix \co{+} and \co{-} are used for pointer
and array computations.
These are all safe in that they operate on an integer and pointer, so
that any cancellation will not normally be detectable at compile time.
However, one big purpose of diagnostics is to detect abnormal conditions
indicating probable bugs.
Therefore, in cases where the compiler can determine that two values
from dependency chains are annihilating each other via
infix \co{+} and \co{-}, a diagnostic would be appropriate.

Similarly, the Linux kernel uses infix (bitwise) \co{&} to manipulate
bits at the bottom of a pointer, where again cancellation will not
normally be detectable at compile time---except in the case of operations
on a \co{NULL} pointer, for which dependency ordering is not meaningful
in any case.
However, as with infix \co{+} and \co{-}, if the compiler detects
value annihilation, a diagnostic would be appropriate.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 struct liststackhead {
 2   struct liststack __rcu *first;
 3 };
 4 
 5 struct liststack {
 6   struct liststack __rcu *next;
 7   void *t;
 8   struct rcu_head rh;
 9 };
10 
11 _Carries_dependency
12 void *ls_front(struct liststackhead *head)
13 {
14   _Carries_dependency void *data;
15   struct liststack *lsp;
16 
17   rcu_read_lock();
18   lsp = rcu_dereference(head->first);
19   if (lsp == NULL)
20     data = NULL;
21   else
22     data = rcu_dereference(lsp->t);
23   rcu_read_unlock();
24   return data;
25 }
\end{verbatim}
}
\caption{List-Based-Stack Example Code, 1 of 2}
\label{fig:List-Based-Stack Example Code, 1 of 2}
\end{figure}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 int ls_push(struct liststackhead *head, void *t)
 2 {
 3   struct liststack *lsp;
 4   struct liststack *lsnp1;
 5   struct liststack *lsnp2;
 6   size_t sz;
 7 
 8   sz = sizeof(*lsp);
 9   sz = (sz + CACHE_LINE_SIZE - 1) / CACHE_LINE_SIZE;
10   sz *= CACHE_LINE_SIZE;
11   lsp = malloc(sz);
12   if (!lsp)
13     return -ENOMEM;
14   if (!t)
15     abort();
16   lsp->t = t;
17   rcu_read_lock();
18   lsnp2 = ACCESS_ONCE(head->first);
19   do {
20     lsnp1 = lsnp2;
21     lsp->next = lsnp1;
22     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
23   } while (lsnp1 != lsnp2);
24   rcu_read_unlock();
25   return 0;
26 }
27 
28 static void ls_rcu_free_cb(struct rcu_head *rhp)
29 {
30   struct liststack *lsp;
31 
32   lsp = container_of(rhp, struct liststack, rh);
33   free(lsp);
34 }
35 
36 _Carries_dependency
37 void *ls_pop(struct liststackhead *head)
38 {
39   _Carries_dependency struct liststack *lsp;
40   struct liststack *lsnp1;
41   _Carries_dependency struct liststack *lsnp2;
42   _Carries_dependency void *data;
43 
44   rcu_read_lock();
45   lsnp2 = rcu_dereference(head->first);
46   do {
47     lsnp1 = lsnp2;
48     if (lsnp1 == NULL) {
49       rcu_read_unlock();
50       return NULL;
51     }
52     lsp = rcu_dereference(lsnp1->next);
53     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
54   } while (lsnp1 != lsnp2);
55   data = rcu_dereference(lsnp2->t);
56   rcu_read_unlock();
57   call_rcu(&lsnp2->rh, ls_rcu_free_cb);
58   return data;
59 }
\end{verbatim}
}
\caption{List-Based-Stack Example Code, 2 of 2}
\label{fig:List-Based-Stack Example Code, 2 of 2}
\end{figure}

Although issues with false positives and negatives needs further
investigation, there is reason to hope that this revision of the
definition of dependency ordering might avoid significant impacts
on ease of use.
With this hope, we proceed to the specific proposals, using
the code in
Figures~\ref{fig:List-Based-Stack Example Code, 1 of 2}
and~\ref{fig:List-Based-Stack Example Code, 2 of 2}
to show some sample code using Linux-kernel nomenclature with the addition
of a mythical C keyword \co{_Carries_dependency} to annotate
parameters, variables, and return values that carry dependencies.
Please note that this code example in no way endorses the dubious
practice of creating a parallel program with the sort of choke point
exemplified by the head of this list.
Note also that \co{cmpxchg()} heads a dependency chain, which is
completely reasonable within the context of the Linux kernel due
to its acquire semantics, which of course might be argued to
indicate that the annotations in \co{ls_pop()} are unnecessary.

\subsection{Type-Based Designation of Dependency Chains With Restrictions}
\label{sec:Type-Based Designation of Dependency Chains With Restrictions}

This approach was formulated by Torvald Riegel in response to
Linus Torvalds's spirited criticisms of the current C11 and C++11
wording.

This approach introduces a new \co{value_dep_preserving} type
qualifier.
Dependency ordering is preserved only via variables having
this type qualifier.
This is meant to model the real scope of dependencies, which is
data flow, not execution at function-level granularity.
This approach should therefore give developers much finer
control of which dependencies are tracked.

Assigning from a \co{value_dep_preserving} value to a
non-\co{value_dep_preserving} variable terminates the tracking
of dependencies in much the same way that an explicit
\co{std::kill_dependency()} would.
However, unlike an explicit \co{std::kill_dependency()}, compilers should
be able to emit a suppressable warning on implicit conversions, so as
to alert the developer about otherwise silent dropping of dependency
tracking.\footnote{
	Other choices are possible in this case, including emitting
	a \co{memory_order_acquire} fence in order to conservatively
	preserve a potentially intended ordering.}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 value_dep_preserving struct foo *p;
 2 
 3 p = atomic_load_explicit(gp, memory_order_consume);
 4 q = some_other_pointer;
 5 if (p == q)
 6   do_something_with(p->a);
 7 else
 8   do_something_else_with(p->b);
\end{verbatim}
}
\caption{Single-Value Variables and Dependency Ordering}
\label{fig:Single-Value Variables and Dependency Ordering}
\end{figure}

Next, we specify that \co{memory_order_consume} loads return a
\co{value_dep_preserving} type by default; the compiler must assume
such a load to be capable of producing any value of the underlying type.
In other words, the implementation is not permitted to apply any
value-restriction knowledge it might gain from whole-program
analysis.
We call this a \emph{local semantic dependency} to distinguish not only
from a pure (syntactic) dependency, but also from a
\emph{global semantic dependency}, where global information may be applied.
Note that any global semantic dependency is also a local semantic
dependency, but that any local semantic dependency which is headed
by a variable that can be proven to take on only a single value is
\emph{not} a global semantic dependency.
The term ``semantic dependency'' should be interpreted to mean a
global semantic dependency unless otherwise stated.

This allows developers to start with a clean slate for the additional
rule that they must follow to be able to rely on dependency ordering:
Subsequent execution must not lead to a situation there is only
one possible value for the \co{value_dep_preserving} expression,
because otherwise the implementation is permitted to break
the dependency chain.
As noted earlier, this is shown in
Figure~\ref{fig:Single-Value Variables and Dependency Ordering},
where the compiler is permitted to break dependency ordering on
line~6 because it knows that the value of \co{p} is equal to that
of \co{q}, which means that it could substitute the latter value
from the former, which would break dependency ordering.

This approach has several advantages:

\begin{enumerate}
\item	The implementation is simpler because no dependency chains
	need to be traced.
	The implementation can instead drive optimization decisions
	strictly from type information.
\item	Use of the \co{value_dep_preserving} type modifier allows
	the developer to limit the extent of the dependency chains.
\item	This type modifier can be used to mark a dependency chain's
	entry to and exit from a function in a straightforward way,
	without the need for attributes.
\item	The \co{value_dep_preserving} type modifiers serve as
	valuable documentation of the developer's intent.
\item	This approach permits many additional optimizations compared
	to those permitted by the current standard on code that
	carries a dependency.
	Expressions such as \co{(x-x)} no longer require establishment of
	artificial dependencies and the compiler is no longer required
	to detect value-narrowing hazards like that shown in
	Figure~\ref{fig:Dependency-Ordering Value-Narrowing Hazard}.
	However, the compiler is still prohibited from adding
	its own value-speculation optimizations.
\item	Linus Torvalds seems to be OK with it, which indicates that this
	set of rules might be practical from the perspective of
	developers who currently exploit dependency chains.
\end{enumerate}

According to Peter Sewell, one disadvantage is that this approach
will be quite difficult to model, which in turn will pose obstacles
for the analysis tooling that will be increasingly necessary for
large-scale concurrent programming efforts.
In particular, the concern is that forcing the compiler to assume
that a \co{memory_order_consume} load could possibly return any
value permitted by its type might require program-analysis tools to
consider counterfactual hypothetical executions, which might
complicate specification of semantics and verification.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 #define rcu_dereference(x) \
 2   atomic_load_explicit((x), memory_order_consume);
 3 
 4 struct liststackhead {
 5   struct liststack value_dep_preserving *first;
 6 };
 7 
 8 struct liststack {
 9   struct liststack value_dep_preserving *next;
10   void *t;
11   struct rcu_head rh;
12 };
13 
14 value_dep_preserving
15 void *ls_front(struct liststackhead *head)
16 {
17   value_dep_preserving void *data;
18   value_dep_preserving struct liststack *lsp;
19 
20   rcu_read_lock();
21   lsp = rcu_dereference(head->first);
22   if (lsp == NULL)
23     data = NULL;
24   else
25     data = rcu_dereference(lsp->t);
26   rcu_read_unlock();
27   return data;
28 }
\end{verbatim}
}
\caption{List-Based-Stack Restricted Type-Based Designation, 1 of 2}
\label{fig:List-Based-Stack Restricted Type-Based Designation, 1 of 2}
\end{figure}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 int ls_push(struct liststackhead *head, void *t)
 2 {
 3   struct liststack *lsp;
 4   struct liststack *lsnp1;
 5   struct liststack *lsnp2;
 6   size_t sz;
 7 
 8   sz = sizeof(*lsp);
 9   sz = (sz + CACHE_LINE_SIZE - 1) / CACHE_LINE_SIZE;
10   sz *= CACHE_LINE_SIZE;
11   lsp = malloc(sz);
12   if (!lsp)
13     return -ENOMEM;
14   if (!t)
15     abort();
16   lsp->t = t;
17   rcu_read_lock();
18   lsnp2 = ACCESS_ONCE(head->first);
19   do {
20     lsnp1 = lsnp2;
21     lsp->next = lsnp1;
22     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
23   } while (lsnp1 != lsnp2);
24   rcu_read_unlock();
25   return 0;
26 }
27 
28 static void ls_rcu_free_cb(struct rcu_head *rhp)
29 {
30   struct liststack *lsp;
31 
32   lsp = container_of(rhp, struct liststack, rh);
33   free(lsp);
34 }
35 
36 value_dep_preserving 
37 void *ls_pop(struct liststackhead *head)
38 {
39   value_dep_preserving struct liststack *lsp;
40   struct liststack *lsnp1;
41   value_dep_preserving struct liststack *lsnp2;
42   value_dep_preserving void *data;
43 
44   rcu_read_lock();
45   lsnp2 = rcu_dereference(head->first);
46   do {
47     lsnp1 = lsnp2;
48     if (lsnp1 == NULL) {
49       rcu_read_unlock();
50       return NULL;
51     }
52     lsp = rcu_dereference(lsnp1->next);
53     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
54   } while (lsnp1 != lsnp2);
55   data = rcu_dereference(lsnp2->t);
56   rcu_read_unlock();
57   call_rcu(&lsnp2->rh, ls_rcu_free_cb);
58   return data;
59 }
\end{verbatim}
}
\caption{List-Based-Stack Restricted Type-Based Designation, 2 of 2}
\label{fig:List-Based-Stack Restricted Type-Based Designation, 2 of 2}
\end{figure}

Figures~\ref{fig:List-Based-Stack Restricted Type-Based Designation, 1 of 2}
and~\ref{fig:List-Based-Stack Restricted Type-Based Designation, 2 of 2}
show how this approach plays out with the list-based stack.

\subsection{Type-Based Designation of Dependency Chains}
\label{sec:Type-Based Designation of Dependency Chains}

Jeff Preshing made an off-list suggestion of using a
\co{value_dep_preserving} type modifier as suggested by Torvald Riegel,
but using this type modifier to strictly enforce dependency ordering.
For example, consider the code fragment shown in
Figure~\ref{fig:Single-Value Variables and Dependency Ordering}.
The scheme described in
Section~\ref{sec:Type-Based Designation of Dependency Chains With Restrictions}
would \emph{not} necessarily enforce dependency ordering between the
load on line~3 and the access one line~6, while the approach described
in this section would enforce dependency ordering in this case.

Furthermore, cancelling or value-destruction operations on
\co{value_dep_preserving} values would \emph{not} disrupt dependency
ordering.
As with the current C11 and C++11 standards, the implementation would be
required to emit a memory-barrier instruction or compute an artificial
dependency for such operations.
(Note however that use of cancelling or value-destruction operations
on dependency chains has proven quite rare in practice.)

This approach shares many of the advantages of Torvald Riegel's approach:

\begin{enumerate}
\item	The implementation is simpler because no dependency chains
	need be traced.
	The implementation can instead drive optimization decisions
	strictly from type information.
\item	Use of the \co{value_dep_preserving} type modifier allows
	the developer to limit the extent of the dependency chains.
\item	This type modifier can be used to mark a dependency chain's
	entry to and exit from a function in a straightforward way,
	without the need for attributes.
\item	The \co{value_dep_preserving} type modifiers serve as
	valuable documentation of the developer's intent.
\item	Although optimizations on a dependency chain are restricted
	just as in the current standard, the use of \co{value_dep_preserving}
	restricts the dependency chains to those intended by the
	developer.
\item	Restricting dependency-breaking optimizations on all dependency
	chains marked \co{value_dep_preserving}, without exceptions for
	cases in which the compiler knows too much, might make this approach
	easier to learn and to use.
\end{enumerate}

It is expected that modeling this approach should be straightforward
because the modeling tools would be able to make use of the type
information.
This approach results in the same code as shown in
Figures~\ref{fig:List-Based-Stack Restricted Type-Based Designation, 1 of 2}
and~\ref{fig:List-Based-Stack Restricted Type-Based Designation, 2 of 2}
of the previous section.

\subsection{Whole-Program Option}
\label{sec:Whole-Program Option}

This approach, also suggested off-list by Jeff Preshing,
has the goal
of reusing existing non-dependency-ordered source code unchanged
(albeit requiring recompilation in most cases).\footnote{
	A module or library that is known to never carry a dependency
	need not be recompiled.}
For example, this approach permits an instance of \co{std::map} to
be referenced by a pointer loaded via \co{memory_order_consume} and to provide
that \co{std::map} instance with the benefits of dependency ordering
without any code changes whatsoever to \co{std::map}.
It is important to note that this protection will be provided only to
a read-only \co{std::map} that is referenced by a changing
pointer loaded via \co{memory_order_consume}, in particular, \emph{not} to a
concurrently updated \co{std::map} referenced by a pointer
(read-only or otherwise) loaded via \co{memory_order_consume}.
This latter case \emph{would} require changes to the underlying
\co{std:map} implementation, at a minimum, changing some of the
loads to be \co{memory_order_consume} loads.
Nevertheless, the ability to provide dependency-ordering protection to
pre-existing linked data structures is valuable, even with
this read-only restriction.

This approach, which again does require full recompilation, can be
implemented using two approaches:

\begin{enumerate}
\item	Promote all \co{memory_order_consume} loads to
	\co{memory_order_acquire}, as may be done with the current standard.
\item	On architectures that respect memory ordering, prohibit all
	dependency-breaking optimizations throughout
	the entire program, but only in cases where a change in the value
	returned by a \co{memory_order_consume} load could cause a change in
	the value computed later in that same dependency chain, in other
	words, where there is a global semantic dependency.
	Note again that the possibility of storing a value obtained from
	a \co{memory_order_consume} load, then loading it later, means
	that normal loads as well as \co{memory_order_relaxed} loads
	often must be considered to head their own dependency chains,
	but only when loaded by the same thread that did the store.
\end{enumerate}

Some implementations might allow the developer to choose between these
two approaches, for example, by using a compiler switch provided for
that purpose.

This approach also has the effect of permitting a trivial implementation
of a \co{memory_order_consume} \co{atomic_thread_fence()}.
When using the first implementation approach, the \co{atomic_thread_fence()}
is simply promoted to \co{memory_order_acquire}.
Interestingly enough, when using the second approach, the
\co{memory_order_consume} \co{atomic_thread_fence()} may simply be ignored.
The reason for this is that this approach has the effect of promoting
\co{memory_order_relaxed} loads to \co{memory_order_consume}, which
already globally enforces all the ordering that the
\co{memory_order_consume} \co{atomic_thread_fence()} is required to
provide locally.\footnote{
	Of course, this presumed promotion from \co{memory_order_relaxed}
	to \co{memory_order_consume} means that architectures such as
	DEC Alpha that do not respect dependency ordering must continue
	to use the first option of emitting memory-ordering instructions
	for \co{memory_order_consume} loads.}

This approach has its own set of advantages and disadvantages:

\begin{enumerate}
\item	This approach dispenses with the \co{[[carries_dependency]]}
	attribute and the \co{std::kill_dependency()} primitive.
\item	This approach better promotes reuse of existing source code.
	In particular, it should require no changes to the current
	Linux-kernel source base, aside from changes to the
	\co{rcu_dereference()} family of primitives.
\item	This approach allows implementations to carry out dependency-breaking
	optimizations on dependency chains as long as a change in
	the value from the \co{memory_order_consume} load does not change
	values further down the dependency chain, both with and without
	the optimization.
	Jeff conjectures that the set of dependency-breaking optimizations
	used in practice apply only outside of dependency chains, by
	the revised definition in which single-value restrictions break
	dependency chains.\footnote{
		This is certainly the case for the usual optimizations
		exemplified by replacing \co{(x-x)} with zero.}
	If this conjecture holds, it also applies to Torvald's
	approach described in
	Section~\ref{sec:Type-Based Designation of Dependency Chains With Restrictions}.
\item	Code that follows the rules presented in
	Section~\ref{sec:Rules for C-Language RCU Users}
	(substituting \co{memory_order_consume} loads for
	\co{volatile} loads)
	would have its dependency ordering properly preserved.
\end{enumerate}

It is unlikely that this approach could be modeled reasonably given
the current state of the art.
The requirement that any given \co{memory_order_consume} load be
able to generate at least two different values at the tail of the
dependency chain is believed to be a show-stopper, especially
when coupled with whole-program analysis, which might find that
there is only one value entering at the head of the dependency chain.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 #define rcu_dereference(x) \
 2   atomic_load_explicit((x), memory_order_consume);
 3 
 4 struct liststackhead {
 5   struct liststack *first;
 6 };
 7 
 8 struct liststack {
 9   struct liststack *next;
10   void *t;
11   struct rcu_head rh;
12 };
13 
14 void *ls_front(struct liststackhead *head)
15 {
16   void *data;
17   struct liststack *lsp;
18 
19   rcu_read_lock();
20   lsp = rcu_dereference(head->first);
21   if (lsp == NULL)
22     data = NULL;
23   else
24     data = rcu_dereference(lsp->t);
25   rcu_read_unlock();
26   return data;
27 }
\end{verbatim}
}
\caption{List-Based-Stack Whole-Program Approach, 1 of 2}
\label{fig:List-Based-Stack Whole-Program Approach, 1 of 2}
\end{figure}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 int ls_push(struct liststackhead *head, void *t)
 2 {
 3   struct liststack *lsp;
 4   struct liststack *lsnp1;
 5   struct liststack *lsnp2;
 6   size_t sz;
 7 
 8   sz = sizeof(*lsp);
 9   sz = (sz + CACHE_LINE_SIZE - 1) / CACHE_LINE_SIZE;
10   sz *= CACHE_LINE_SIZE;
11   lsp = malloc(sz);
12   if (!lsp)
13     return -ENOMEM;
14   if (!t)
15     abort();
16   lsp->t = t;
17   rcu_read_lock();
18   lsnp2 = ACCESS_ONCE(head->first);
19   do {
20     lsnp1 = lsnp2;
21     lsp->next = lsnp1;
22     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
23   } while (lsnp1 != lsnp2);
24   rcu_read_unlock();
25   return 0;
26 }
27 
28 static void ls_rcu_free_cb(struct rcu_head *rhp)
29 {
30   struct liststack *lsp;
31 
32   lsp = container_of(rhp, struct liststack, rh);
33   free(lsp);
34 }
35 
36 void *ls_pop(struct liststackhead *head)
37 {
38   struct liststack *lsp;
39   struct liststack *lsnp1;
40   struct liststack *lsnp2;
41   void *data;
42 
43   rcu_read_lock();
44   lsnp2 = rcu_dereference(head->first);
45   do {
46     lsnp1 = lsnp2;
47     if (lsnp1 == NULL) {
48       rcu_read_unlock();
49       return NULL;
50     }
51     lsp = rcu_dereference(lsnp1->next);
52     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
53   } while (lsnp1 != lsnp2);
54   data = rcu_dereference(lsnp2->t);
55   rcu_read_unlock();
56   call_rcu(&lsnp2->rh, ls_rcu_free_cb);
57   return data;
58 }
\end{verbatim}
}
\caption{List-Based-Stack Whole-Program Approach, 2 of 2}
\label{fig:List-Based-Stack Whole-Program Approach, 2 of 2}
\end{figure}

This approach allows annotations to be discarded, as shown in
Figures~\ref{fig:List-Based-Stack Whole-Program Approach, 1 of 2}
and~\ref{fig:List-Based-Stack Whole-Program Approach, 2 of 2}.
However, the \co{memory_order_consume} loads are still required
in order to enable the promote-to-acquire implementation style.

\subsection{Local-Variable Restriction}
\label{sec:Local-Variable Restriction}

This approach, suggested off-list by Hans Boehm, limits the extent of
dependency trees to a local, which includes local variables, temporaries,
function arguments, and return variables.
Assigning a value from a \co{memory_order_consume} load to such an
object begins a dependency chain.
Assigning a value loaded from such a local to
a global variable (including function-local variables marked \co{static})
or to the heap implies a \co{std::kill_dependency()},
so that dependency chains are confined to locals.
However, if the compiler is unable to see the full dependency chain,
for example, because it passes into a function in another translation
unit that is not marked \co{[[carries_dependency]]}, the compiler
should promote \co{memory_order_consume} to
\co{memory_order_acquire}.\footnote{
	Some implementations might provide means to allow the user to
	specify that a diagnostic be generated if such promotion is
	necessary.}

Section~\ref{sec:Operators in Linux-Kernel Dependency Chains}
indicates that
the following operators should transmit dependency status from
one local variable or temporary to another:
\co{->}, infix \co{=}, casts, prefix \co{&}, prefix \co{*}, \co{[]},
infix \co{+}, infix \co{-}, ternary \co{?:}, infix (bitwise) \co{&},
and probably also \co{|}.
Similarly,
Section~\ref{sec:Operators Terminating Linux-Kernel Dependency Chains}
indicates that the following operators should imply a
\co{std::kill_dependency()}:
\co{()}, \co{!}, \co{==}, \co{!=}, \co{&&}, \co{||}, infix \co{*}, \co{/},
and \co{\%}.

It will also be necesary to check whether Linux-kernel usage expects
dependency chains to pass through globals and heap objects that are
in some way thread-local.
If there are such use cases, and if they are sane and cannot easily
be changed to use local variables, should \co{[[carries_dependency]]}
be used to flag dependency-carrying globals and heap objects?

This approach has the following advantages and disadvantages:

\begin{enumerate}
\item	This approach requires that the C language add the
	\co{[[carries_dependency]]} attribute if dependency chains are to
	span multiple translation units, as is the case in some parts of
	the Linux kernel.
\item	The implementation is likely to be somewhat simpler because only those
	dependency chains passing through local variables,
	compiler-generated temporaries, compiler-visible function arguments,
	and compiler-visible return values need be traced.
	One could also argue that function arguments and return values
	marked with \co{[[carries_dependency]]} attribute also need to
	be traced.
\item	Many irrelevant dependency chains are pruned by default, thus
	fewer \co{std::kill_dependency()} calls are required.
\item	Although optimizations on dependency chains must be restricted,
	the restricted scope of dependency chains reduces the impact
	of these restrictions.
\item	Applying this approach to the Linux kernel would only require
	the addition of markings on function parameters and return values
	corresponding to cross-translation-unit function calls.
	However, there are a significant number of these, so this
	approach can expect significant resistance from the Linux
	community.
\end{enumerate}

It is expected that modeling this approach should be no more difficult
than for the current C11 and C++11 standards.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 #define rcu_dereference(x) \
 2   atomic_load_explicit((x), memory_order_consume);
 3 
 4 struct liststackhead {
 5   struct liststack *first;
 6 };
 7 
 8 struct liststack {
 9   struct liststack *next;
10   void *t;
11   struct rcu_head rh;
12 };
13 
14 _Carries_dependency
15 void *ls_front(struct liststackhead *head)
16 {
17   void *data;
18   struct liststack *lsp;
19 
20   rcu_read_lock();
21   lsp = rcu_dereference(head->first);
22   if (lsp == NULL)
23     data = NULL;
24   else
25     data = rcu_dereference(lsp->t);
26   rcu_read_unlock();
27   return data;
28 }
\end{verbatim}
}
\caption{List-Based-Stack Local-Variable Restriction, 1 of 2}
\label{fig:List-Based-Stack Local-Variable Restriction, 1 of 2}
\end{figure}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 int ls_push(struct liststackhead *head, void *t)
 2 {
 3   struct liststack *lsp;
 4   struct liststack *lsnp1;
 5   struct liststack *lsnp2;
 6   size_t sz;
 7 
 8   sz = sizeof(*lsp);
 9   sz = (sz + CACHE_LINE_SIZE - 1) / CACHE_LINE_SIZE;
10   sz *= CACHE_LINE_SIZE;
11   lsp = malloc(sz);
12   if (!lsp)
13     return -ENOMEM;
14   if (!t)
15     abort();
16   lsp->t = t;
17   rcu_read_lock();
18   lsnp2 = ACCESS_ONCE(head->first);
19   do {
20     lsnp1 = lsnp2;
21     lsp->next = lsnp1;
22     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
23   } while (lsnp1 != lsnp2);
24   rcu_read_unlock();
25   return 0;
26 }
27 
28 static void ls_rcu_free_cb(struct rcu_head *rhp)
29 {
30   struct liststack *lsp;
31 
32   lsp = container_of(rhp, struct liststack, rh);
33   free(lsp);
34 }
35 
36 _Carries_dependency
37 void *ls_pop(struct liststackhead *head)
38 {
39   struct liststack *lsp;
40   struct liststack *lsnp1;
41   struct liststack *lsnp2;
42   void *data;
43 
44   rcu_read_lock();
45   lsnp2 = rcu_dereference(head->first);
46   do {
47     lsnp1 = lsnp2;
48     if (lsnp1 == NULL) {
49       rcu_read_unlock();
50       return NULL;
51     }
52     lsp = rcu_dereference(lsnp1->next);
53     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
54   } while (lsnp1 != lsnp2);
55   data = rcu_dereference(lsnp2->t);
56   rcu_read_unlock();
57   call_rcu(&lsnp2->rh, ls_rcu_free_cb);
58   return data;
59 }
\end{verbatim}
}
\caption{List-Based-Stack Local-Variable Restriction, 2 of 2}
\label{fig:List-Based-Stack Local-Variable Restriction, 2 of 2}
\end{figure}

This approach allows local-variable annotations to be dropped, as
shown in
Figure~\ref{fig:List-Based-Stack Local-Variable Restriction, 1 of 2}
and~\ref{fig:List-Based-Stack Local-Variable Restriction, 2 of 2}

\subsection{Mark Dependency-Carrying Local Variables}
\label{sec:Mark Dependency-Carrying Local Variables}

This approach, suggested offlist by Clark Nelson, uses the
\co{[[carries_dependency]]} attribute to mark non-static local-scope
variables as carrying a dependency, in addition to its current use
marking function arguments and return values as carrying dependencies.
It is not permissible to mark global variables or structure members
with this attribute.
Assigning from a \co{[[carries_dependency]]} object to a
non-\co{[[carries_dependency]]} object results in an implicit
\co{std::kill_dependency()}.

This approach is similar to that of
Section~\ref{sec:Type-Based Designation of Dependency Chains},
except that it uses an attribute rather than a type modifier.
As such, it has many of the advantages and disadvantages of that
approach, however, some believe that an attribute-based approach
will be more acceptable to the committee than would a type-modifier
approach.\footnote{
	Lawrence Crowl suggests a third approach, namely a variable
	modifier.}
However, this approach does require that C add attributes.

This leave the question of which operators transmit dependency
chains from one \co{[[carries_dependency]]} object to another.
Section~\ref{sec:Operators in Linux-Kernel Dependency Chains}
indicates that
the following operators should transmit dependency status from
one local variable or temporary to another:
\co{->}, infix \co{=}, casts, prefix \co{&}, prefix \co{*}, \co{[]},
infix \co{+}, infix \co{-}, ternary \co{?:}, infix (bitwise) \co{&},
and probably also \co{|}.
Similarly,
Section~\ref{sec:Operators Terminating Linux-Kernel Dependency Chains}
shows that the following operators should imply a
\co{std::kill_dependency()}:
\co{()}, \co{!}, \co{==}, \co{!=}, \co{&&}, \co{||}, infix \co{*}, \co{/},
and \co{\%}.

This approach has the following advantages and disadvantages:

\begin{enumerate}
\item	This approach requires that the C language add the
	\co{[[carries_dependency]]} attribute.
\item	The implementation is likely to be simpler because only those
	dependency chains passing through variables marked with the
	\co{[[carries_dependency]]} attribute need be traced.
\item	Many irrelevant dependency chains are pruned by default, thus
	fewer \co{std::kill_dependency()} calls are required.
\item	The \co{[[carries_dependency]]} calls serve as valuable documentation
	of the developer's intent.
\item	Although optimizations on dependency chains must be restricted,
	use of explicit \co{[[carries_dependency]]} greatly reduces
	unnecessary restriction of optimizations on unintentional
	dependency chains.
\item	Applying this to the Linux kernel would require significant
	marking of variables carrying dependencies, given that the
	Linux kernel currently requires no such markings.
\item	Common types of abstraction need to be handled correctly.
	For example, there are more than 500 invocations of
	\co{list_for_each_entry_rcu()} in the v4.1 Linux kernel,
	each of which heads a distinct dependency chain.
	In addition, some of these distinct dependency chains invoke
	common functions and macros.
	It is not clear that compile-time marking suffices for these
	cases.
\end{enumerate}

It is expected that modeling this approach should be no more difficult
than for the current C11 and C++11 standards.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 #define rcu_dereference(x) \
 2   atomic_load_explicit((x), memory_order_consume);
 3 
 4 struct liststackhead {
 5   struct liststack *first;
 6 };
 7 
 8 struct liststack {
 9   struct liststack *next;
10   void *t;
11   struct rcu_head rh;
12 };
13 
14 _Carries_dependency
15 void *ls_front(struct liststackhead *head)
16 {
17   _Carries_dependency void *data;
18   _Carries_dependency struct liststack *lsp;
19 
20   rcu_read_lock();
21   lsp = rcu_dereference(head->first);
22   if (lsp == NULL)
23     data = NULL;
24   else
25     data = rcu_dereference(lsp->t);
26   rcu_read_unlock();
27   return data;
28 }
\end{verbatim}
}
\caption{List-Based-Stack Marked Local Variables, 1 of 2}
\label{fig:List-Based-Stack Marked Local Variables, 1 of 2}
\end{figure}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 int ls_push(struct liststackhead *head, void *t)
 2 {
 3   struct liststack *lsp;
 4   struct liststack *lsnp1;
 5   struct liststack *lsnp2;
 6   size_t sz;
 7 
 8   sz = sizeof(*lsp);
 9   sz = (sz + CACHE_LINE_SIZE - 1) / CACHE_LINE_SIZE;
10   sz *= CACHE_LINE_SIZE;
11   lsp = malloc(sz);
12   if (!lsp)
13     return -ENOMEM;
14   if (!t)
15     abort();
16   lsp->t = t;
17   rcu_read_lock();
18   lsnp2 = ACCESS_ONCE(head->first);
19   do {
20     lsnp1 = lsnp2;
21     lsp->next = lsnp1;
22     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
23   } while (lsnp1 != lsnp2);
24   rcu_read_unlock();
25   return 0;
26 }
27 
28 static void ls_rcu_free_cb(struct rcu_head *rhp)
29 {
30   struct liststack *lsp;
31 
32   lsp = container_of(rhp, struct liststack, rh);
33   free(lsp);
34 }
35 
36 _Carries_dependency
37 void *ls_pop(struct liststackhead *head)
38 {
39   _Carries_dependency struct liststack *lsp;
40   struct liststack *lsnp1;
41   _Carries_dependency struct liststack *lsnp2;
42   _Carries_dependency void *data;
43 
44   rcu_read_lock();
45   lsnp2 = rcu_dereference(head->first);
46   do {
47     lsnp1 = lsnp2;
48     if (lsnp1 == NULL) {
49       rcu_read_unlock();
50       return NULL;
51     }
52     lsp = rcu_dereference(lsnp1->next);
53     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
54   } while (lsnp1 != lsnp2);
55   data = rcu_dereference(lsnp2->t);
56   rcu_read_unlock();
57   call_rcu(&lsnp2->rh, ls_rcu_free_cb);
58   return data;
59 }
\end{verbatim}
}
\caption{List-Based-Stack Marked Local Variables, 2 of 2}
\label{fig:List-Based-Stack Marked Local Variables, 2 of 2}
\end{figure}

This approach results in code as shown in
Figures~\ref{fig:List-Based-Stack Marked Local Variables, 1 of 2}
and~\ref{fig:List-Based-Stack Marked Local Variables, 2 of 2},
where the \co{[[carries_dependency]]} attributes have been replaced
with a mythical \co{_Carries_dependency} C keyword.

\subsection{Explicitly Tail-Marked Dependency Chains}
\label{sec:Explicitly Tail-Marked Dependency Chains}

This approach, suggested at Rapperswil by Olivier Giroux, can be thought
of as the inverse of \co{std::kill_dependency()}.
Instead of explicitly marking where the dependency chains terminate,
Olivier's proposal uses a \co{std::dependency()} primitive to indicate
the locations in the code that the dependency chains are required to reach.
The first argument to \co{std::dependency()} is the value to which the
dependency must be carried, and the second argument is the variable that
heads the dependency chain, in other words, the second argument is the
variable that was loaded from by a \co{memory_order_consume} load.
This proposal differs from the others in that it is expected to be
implemented not necessarily by preserving the dependency, but instead
by inserting barriers in those cases where optimizations have eliminated
any required dependencies.
The goal here is to impose minimal restrictions on optimizations of
code containing dependency chains.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 p = atomic_load_explicit(&gp, memory_order_consume);
 2 if (p != NULL)
 3   do_it(atomic_dependency(p, gp));
\end{verbatim}
}
\caption{Explicit Dependency Operations}
\label{fig:Explicit Dependency Operations}
\end{figure}

A C-language example is shown in
Figure~\ref{fig:Explicit Dependency Operations},
where \co{std::dependency()} is transliterated to the C-language
\co{atomic_dependency()} function.
On line~3, \co{atomic_dependency()} returns the value of its first
argument (\co{p}), while ensuring that the data dependency from
the \co{memory_order_consume} load from \co{gp} is faithfully reflected
in the assembly language implementing this code fragment.
The assembly-language reflection of this dependency might be in terms
of an assembly-language dependency (for example, on ARM or PowerPC),
implicit memory ordering (for example, on x86 or mainframe), or
by an explicit memory-barrier instruction.
However, if there was no \co{atomic_dependency()} function, the compiler
would be under no obligation to preserve the dependency.\footnote{
	Would it be better to have the second argument to
	\co{atomic_dependency()} be a label rather than an expression?}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 void foo(struct bar *q [[carries_dependency]])
 2 {
 3   if (q != NULL)
 4     do_it(atomic_dependency(q->b, q));
 5 }
 6 
 7 p = atomic_load_explicit(&gp, memory_order_consume);
 8 foo(atomic_dependency(p, gp));
\end{verbatim}
}
\caption{Explicit Dependency Operations and carries\_dependency}
\label{fig:Explicit Dependency Operations and carries-dependency}
\end{figure}

These explicitly specified dependencies may be combined with
\co{[[carries_dependency]]} attributes on function arguments,
for example, as shown in
Figure~\ref{fig:Explicit Dependency Operations and carries-dependency}.
Note the interplay of \co{atomic_dependency()} and \co{[[carries_dependency]]},
where line~8 establishes the dependency between the load from \co{gp}
and the \co{[[carries_dependency]]} argument \co{q} of \co{foo()},
and where line~4 establishes the further dependency between argument
\co{q} of \co{foo()} and \co{do_it()}s argument.

This approach is not yet complete.
One issue is the possibility of a given operation being dependent on
multiple \co{memory_order_consume} loads.
One approach is of course to omit this functionality, and another is
to allow \co{atomic_dependency()} to allow an expression as its first
argument and a variable list of \co{memory_order_consume} loaded
variables.

Another issue is connecting \co{[[carries_dependency]]} return values
to subsequent \co{atomic_dependency()} invocations.
There are a number of possible resolutions to this issue.
One approach would be to use \co{[[carries_dependency]]} attribute to
mark the declaration of the variable to which the function's return
value is assigned, bringing the proposal from
Section~\ref{sec:Mark Dependency-Carrying Local Variables}
to bear.
In the special case where the \co{memory_order_consume} load is in the
same function body as the \co{atomic_dependency()} that depends on it,
the \co{atomic_dependency()} could reference the variable that was the
source of the original \co{memory_order_consume} load.
Another approach would be to allow function-return \co{carries_dependency]]}
attributes to define names that could be used by later \co{atomic_dependency()}
invocations.

A third issue arises when \co{atomic_dependency()}
must be applied after the head of the dependency chain has gone
out of scope, for example, if the head was contained in a variable
defined in an inner scope that has since been exited.

A fourth issue arises if optimizations along a needed dependency chain
allow ordering the dependent operation to precede the head of the
dependency chain, in which case inserting barriers would be ineffective.
The current proposal for addressing this issue is to suppress memory-movement
optimizations across the \co{atomic_dependency()}, perhaps using something
like \co{atomic_signal_fence()} or the Linux kernel's \co{barrier()}
macro.
This approach allows dependency checking and fence insertion to be carried
out as a final pass in the compilation process.

This approach has the following advantages and disadvantages:

\begin{enumerate}
\item	This approach requires that the C language add the
	\co{[[carries_dependency]]} attribute.
\item	The implementation is likely to be simpler because only those
	dependency chains having explicit \co{atomic_dependency()}
	calls (and, optionally, intermediate \co{[[carries_dependency]]}
	attributes) need be traced.
\item	Irrelevant dependency chains are pruned by default, with no
	\co{std::kill_dependency()} calls required.
\item	The \co{atomic_dependency()} calls serve as valuable documentation
	of the developer's intent.
\item	Although optimizations on dependency chains must be restricted,
	use of explicit \co{atomic_dependency()} greatly reduces
	unnecessary restriction of optimizations on unintentional
	dependency chains.
\item	Applying this to the Linux kernel would require significant
	marking of dependency chains, given that the Linux kernel currently
	relies on implicit ends of dependency chains.
\item	Common types of abstraction need to be handled correctly.
	For example, there are more than 500 invocations of
	\co{list_for_each_entry_rcu()} in the v4.1 Linux kernel,
	each of which heads a distinct dependency chain.
	In addition, some of these distinct dependency chains invoke
	common functions and macros.
	It is not clear that compile-time marking suffices for these
	cases.
\end{enumerate}

It is not yet known whether this approach can be reasonably modeled.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 #define rcu_dereference(x) \
 2   atomic_load_explicit((x), memory_order_consume);
 3 
 4 struct liststackhead {
 5   struct liststack *first;
 6 };
 7 
 8 struct liststack {
 9   struct liststack *next;
10   void *t;
11   struct rcu_head rh;
12 };
13 
14 _Carries_dependency
15 void *ls_front(struct liststackhead *head)
16 {
17   void *data;
18   struct liststack *lsp;
19 
20   rcu_read_lock();
21   lsp = rcu_dereference(head->first);
22   if (lsp == NULL)
23     data = NULL;
24   else
25     data =
26       rcu_dereference(atomic_dependency(lsp->t,
27                                         head->first));
28   rcu_read_unlock();
29   return atomic_dependency(data, lsp->t);
30 }
\end{verbatim}
}
\caption{List-Based-Stack Tail-Marked Dependencies, 1 of 2}
\label{fig:List-Based-Stack Tail-Marked Dependencies, 1 of 2}
\end{figure}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 int ls_push(struct liststackhead *head, void *t)
 2 {
 3   struct liststack *lsp;
 4   struct liststack *lsnp1;
 5   struct liststack *lsnp2;
 6   size_t sz;
 7 
 8   sz = sizeof(*lsp);
 9   sz = (sz + CACHE_LINE_SIZE - 1) / CACHE_LINE_SIZE;
10   sz *= CACHE_LINE_SIZE;
11   lsp = malloc(sz);
12   if (!lsp)
13     return -ENOMEM;
14   if (!t)
15     abort();
16   lsp->t = t;
17   rcu_read_lock();
18   lsnp2 = ACCESS_ONCE(head->first);
19   do {
20     lsnp1 = lsnp2;
21     lsp->next = lsnp1;
22     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
23   } while (lsnp1 != lsnp2);
24   rcu_read_unlock();
25   return 0;
26 }
27 
28 static void ls_rcu_free_cb(struct rcu_head *rhp)
29 {
30   struct liststack *lsp;
31 
32   lsp = container_of(rhp, struct liststack, rh);
33   free(lsp);
34 }
35 
36 _Carries_dependency
37 void *ls_pop(struct liststackhead *head)
38 {
39   struct liststack *lsp;
40   struct liststack *lsnp1;
41   struct liststack *lsnp2;
42   void *data;
43 
44   rcu_read_lock();
45   lsnp2 = rcu_dereference(head->first);
46   do {
47     lsnp1 = lsnp2;
48     if (lsnp1 == NULL) {
49       rcu_read_unlock();
50       return NULL;
51     }
52     lsp = rcu_dereference(lsnp1->next);
53     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
54   } while (lsnp1 != lsnp2);
55   data = rcu_dereference(atomic_dependency(lsnp2->t, lsnp));
56   rcu_read_unlock();
57   call_rcu(&lsnp2->rh, ls_rcu_free_cb);
58   return atomic_dereference(data, lsnp2->t);
59 }
\end{verbatim}
}
\caption{List-Based-Stack Tail-Marked Dependencies, 2 of 2}
\label{fig:List-Based-Stack Tail-Marked Dependencies, 2 of 2}
\end{figure}

The result is shown in
Figures~\ref{fig:List-Based-Stack Tail-Marked Dependencies, 1 of 2}
and~\ref{fig:List-Based-Stack Tail-Marked Dependencies, 2 of 2}.

\subsection{Explicitly Head-Marked Dependency Chains}
\label{sec:Explicitly Head-Marked Dependency Chains}

This approach, suggested via email by Olivier Giroux, can be thought of
as another inverse of \co{std::kill_dependency()}.
In this case the heads of the dependency chains are marked, indicating
to which pointed-to objects dependencies should be carried.
This description is an extrapolation of a very concise proposal,
and corrections are welcome.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 struct foo {
 2   struct foo *a;
 3   struct foo *b;
 4   struct foo *c;
 5   int d;
 6 };
 7 
 8 p = atomic_load_explicit(&gp, memory_order_consume,
 9                          p->a, p->b);
10 qa = p->a; /* Dependency carried. */
11 qb = p->b; /* Dependency carried. */
12 qc = p->c; /* No dependency carried. */
13 d = p->d; /* No dependency carried. */
\end{verbatim}
}
\caption{Explicit Dependency Operations and Augmented Load}
\label{fig:Explicit Dependency Operations and Augmented Load}
\end{figure}

The general idea is to provide an augmented form of the \co{load()} member
function that indicates dependencies, for example,
\co{x.load(memory_order_consume, x->next)} would cause a dependency to
be carried through the \co{->next} field, but through no other field.
This is shown in
Figure~\ref{fig:Explicit Dependency Operations and Augmented Load},
where the explicit dependency information on line~9 causes lines~10
and~11 to carry a dependency, but lines~12 and~13 not to do so.

Some open questions regarding this approach:

\begin{enumerate}
\item	How does this interact with arguments and return values?
	Do the corresponding annotations need to indicate to which
	fields dependencies might be carried?
	Should mismatches be considered an error, and if so, which
	sorts of mismatches?
\item	How are opaque types handled?
	For example, consider the Linux kernel linked-list facility,
	which embeds a \co{list_head} structure into the enclosing
	object that is to be placed on the list.
	The \co{memory_order_consume} load returns a \co{(struct list_head *)},
	but it may be necessary to carry a dependency to one or more of
	the fields in the enclosing object.
	Should this be handled via something like
	\co{x.load(memory_order_consume, *x)},
	but if so, doesn't this re-introduce the need for lots of
	\co{std::kill_dependency()} calls?
\item	Larger structures might have quite a few fields that need
	dependencies carried.
	Should there be some sort of shorthand to make this easier
	to code, for example, tagging the fields needing dependency
	ordering in the declaration of the \co{struct} or \co{class}?
\item	Common types of abstraction need to be handled correctly.
	For example, there are more than 500 invocations of
	\co{list_for_each_entry_rcu()} in the v4.1 Linux kernel,
	each of which heads a distinct dependency chain.
	In addition, some of these distinct dependency chains invoke
	common functions and macros.
	It is not clear that compile-time marking suffices for these
	cases.
\end{enumerate}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 #define rcu_dereference(x) \
 2   atomic_load_explicit((x), memory_order_consume);
 3 
 4 struct liststackhead {
 5   struct liststack *first;
 6 };
 7 
 8 struct liststack {
 9   struct liststack *next;
10   void *t;
11   struct rcu_head rh;
12 };
13 
14 _Carries_dependency
15 void *ls_front(struct liststackhead *head)
16 {
17   void *data;
18   struct liststack *lsp;
19 
20   rcu_read_lock();
21   lsp = rcu_dereference(head->first, head->first->t);
22   if (lsp == NULL)
23     data = NULL;
24   else
25     data =
26       rcu_dereference(lsp->t, *lsp->t)); /* ??? */
28   rcu_read_unlock();
29   return data;
30 }
\end{verbatim}
}
\caption{List-Based-Stack Head-Marked Dependencies, 1 of 2}
\label{fig:List-Based-Stack Head-Marked Dependencies, 1 of 2}
\end{figure}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 int ls_push(struct liststackhead *head, void *t)
 2 {
 3   struct liststack *lsp;
 4   struct liststack *lsnp1;
 5   struct liststack *lsnp2;
 6   size_t sz;
 7 
 8   sz = sizeof(*lsp);
 9   sz = (sz + CACHE_LINE_SIZE - 1) / CACHE_LINE_SIZE;
10   sz *= CACHE_LINE_SIZE;
11   lsp = malloc(sz);
12   if (!lsp)
13     return -ENOMEM;
14   if (!t)
15     abort();
16   lsp->t = t;
17   rcu_read_lock();
18   lsnp2 = ACCESS_ONCE(head->first);
19   do {
20     lsnp1 = lsnp2;
21     lsp->next = lsnp1;
22     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
23   } while (lsnp1 != lsnp2);
24   rcu_read_unlock();
25   return 0;
26 }
27 
28 static void ls_rcu_free_cb(struct rcu_head *rhp)
29 {
30   struct liststack *lsp;
31 
32   lsp = container_of(rhp, struct liststack, rh);
33   free(lsp);
34 }
35 
36 _Carries_dependency
37 void *ls_pop(struct liststackhead *head)
38 {
39   struct liststack *lsp;
40   struct liststack *lsnp1;
41   struct liststack *lsnp2;
42   void *data;
43 
44   rcu_read_lock();
45   lsnp2 = rcu_dereference(head->first, head->first->next);
46   do {
47     lsnp1 = lsnp2;
48     if (lsnp1 == NULL) {
49       rcu_read_unlock();
50       return NULL;
51     }
52     lsp = rcu_dereference(lsnp1->next, lsnp->next->t);
53     lsnp2 = cmpxchg(&head->first, lsnp1, lsp);
54   } while (lsnp1 != lsnp2);
55   data = rcu_dereference(lsnp2->t, *lsnp2->t));
56   rcu_read_unlock();
57   call_rcu(&lsnp2->rh, ls_rcu_free_cb);
58   return data;
59 }
\end{verbatim}
}
\caption{List-Based-Stack Head-Marked Dependencies, 2 of 2}
\label{fig:List-Based-Stack Head-Marked Dependencies, 2 of 2}
\end{figure}

\subsection{Restricted Dependency Chains}
\label{sec:Restricted Dependency Chains}

This approach restricts dependency chains to operations for which
compilers would naturally carry dependencies.
As such, this approach can be considered to be a refinement of
the whole-program option (Section~\ref{sec:Whole-Program Option}),
restricted as described in
Section~\ref{sec:Rules for 2003 GCC Implementations},
but also omitting control dependencies and RCU-protected array indexes.
It can also be thought of as a refinement of the local-variable
restriction
(Section~\ref{sec:Local-Variable Restriction}).
As always, a \co{memory_order_consume} load heads a dependency chain,
and as always, a \co{memory_order_consume} load may be implemented
with a simple load instruction on a wide variety of architectures,
including x86, ARM, and Power.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 #define rcu_ptr_extract(p) \
 2 ({ \
 3   uintptr_t ___ip = (uintptr_t)(p); \
 4   \
 5   ___ip = ___ip & ~0x7; \
 6   (typeof(p)) ___ip; \
 7 })
 8 
 9 #define rcu_ptr_set_bits(p, bits) \
10 ({ \
11   uintptr_t ___ip = (uintptr_t)(p); \
12   \
13   ___ip = ___ip & ~0x7; \
14   ___ip = ___ip | (bits); \
15   (typeof(p)) ___ip; \
16 })
17 
18 #define rcu_ptr_get_bits(p, bits) \
19 ({ \
20   uintptr_t ___ip = (uintptr_t)(p); \
21   \
22   ___ip & ~0x7; \
23 })
\end{verbatim}
}
\caption{Pointers and Bit Manipulation on 64-Bit System}
\label{fig:Pointers and Bit Manipulation on 64-Bit System}
\end{figure}

This results in a specific list of operations that extend dependency chains
(Section~\ref{sec:Extending Dependency Chains})
and a separate specific list of operations that terminate such chains
(Section~\ref{sec:Terminating Dependency Chains}).
Section~\ref{sec:Restricted Dependency Chains and the Linux Kernel}
looks at how this approach relates to the Linux kernel, and
Section~\ref{sec:Restricted Dependency Chains: Advantages and Disavantages}
lists this approach's advantages and disadvantages.

It is worth repeating that key goals include minimizing the need
for \co{std::kill_dependency()} and minimizing unsolicited
memory-barrier instructions.

\subsubsection{Extending Dependency Chains}
\label{sec:Extending Dependency Chains}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 p = rcu_dereference(gp);
 2 *p = 5;
\end{verbatim}
}
\caption{Extending Dependency Chain on Left-Hand Side}
\label{fig:Extending Dependency Chain on Left-Hand Side}
\end{figure}

The following categories of primitive operations extend dependency
chains:\footnote{
	In case of operator overloading, the actual functions called must
	be analyzed in order to determine their effects on dependency
	chains.}

\begin{enumerate}
\item	Moving, copying, and casting.
\item	Pointer offsets.
\item	Dereferencing and address-of, including class-member access.
\item	Integer operations.
\item	Miscellaneous operators.
\end{enumerate}

Any other operation terminates a dependency chain.
The operations that extend dependency chains are covered in more
detail below.

\paragraph{Moving, Copying, and Casting:}

Values that are part of a dependency chain may be moved, copied,
and casted (in some cases), and the dependency chain will propagate
to the result.

\begin{enumerate}
\item	If any value is part of a dependency chain, then using
	that value as the left-hand side of an assignment expression
	extends the chain to cover the assignment.
	This rule is exercised in the Linux kernel by stores into
	fields making up an RCU protected data element.
	This is illustrated by
	Figure~\ref{fig:Extending Dependency Chain on Left-Hand Side}.
\item	If any value is part of a dependency chain, then using that
	value as the right-hand side of an assignment expression
	extends the chain to cover both the assignment and the value
	returned by that assignment statement.
	Line~20 of
	Figure~\ref{fig:List-Based-Stack Whole-Program Approach, 1 of 2}
	shows how this rule may be used to extend a dependency chain
	into a local variable.
\item	If any value that is part of a dependency chain is stored to
	a non-shared variable, then any value loaded by a later load
	from that same variable by that same thread is also part of
	the dependency chain.
	Lines~20 and~24 of
	Figure~\ref{fig:List-Based-Stack Whole-Program Approach, 1 of 2}
	illustrate this rule, though this rule would apply even if
	local variable \co{lsp} was a \co{intptr_t} instead of a pointer.
	Note that the job of determining whether or not a given variable
	is non-shared falls to the developer, \emph{not} the compiler.
	That said, a high-QoI compiler might choose to make this determination
	in order to issue helpful diagnostic messages.
\item	If a pointer that is part of a dependency chain is stored to
	any variable, then any value loaded by a later load
	from that same variable by that same thread is also part of
	the dependency chain.
	Lines~20 and~24 of
	Figure~\ref{fig:List-Based-Stack Whole-Program Approach, 1 of 2}
	illustrate this rule, though this rule would apply even if
	local variable \co{lsp} was instead a shared variable.
	As before, determining whether or not the store and load were
	carried out by the same thread falls to the developer, not
	to the compiler.
\item	If a pointer is part of a dependency chain, then casting it
	(either explicitly or implicitly) to any pointer-sized type
	extends the chain to the result.
	Line~3 of
	Figure~\ref{fig:Pointers and Bit Manipulation on 64-Bit System}
	illustrates this rule.
\item	If a value of type \co{intptr_t} or \co{uintptr_t} is part of
	a dependency chain, then casting it to a pointer type
	extends the chain to the result.
	Line~6 of
	Figure~\ref{fig:Pointers and Bit Manipulation on 64-Bit System}
	illustrates this rule.
	Note that many implementations do not differentiate between
	\co{intptr_t} and \co{uintptr_t} on the one hand and other
	integral types on the other.
	Such implementations would likely loosen this restriction to
	cover a larger subset of the integral types.
\item	If a pointer is part of a dependency chain, then if that pointer
	is used as the argument of a function call, the
	dependency chain extends to the corresponding parameter.
\item	If a function returns a pointer that is part of a dependency
	chain, the dependency chain extends to the returned value in
	the calling function.
\end{enumerate}

\paragraph{Pointer Offsets:}

If a given pointer is part of a dependency chain, then integral offsets
to that pointer are also part of that dependency chain.

\begin{enumerate}
\item	If a pointer is part of a dependency chain, then adding an integral
	value to that pointer extends the chain to the resulting value.
	This applies for both positive and negative integers, and also
	to addition via the infix \co{+} operator and via the postfix
	\co{[]} operator.
	Note that the addition must be carried out on a pointer:
	Casting to an integral type and then carrying out the addition
	will break the dependency chain.
	Therefore, instead of casting to an integral type to carry
	out the addition, cast to a pointer to \co{char}.\footnote{
		Yes, some old systems had strange formats for character
		pointers, and this restriction does exclude those systems
		from this nuance of dependency ordering.
		However, to the best of my knowledge, all such
		systems were uniprocessors, so this is not a real problem.}
	Line~24 of
	Figure~\ref{fig:List-Based-Stack Whole-Program Approach, 1 of 2}
	illustrates this, given that the \co{->t} acts as a pointer offset
	prior to indirection.
\item	If a pointer is part of a dependency chain, then subtracting an integer
	from that pointer extends the chain to the resulting value.
	This applies for both positive and negative integers.
	Again, casting to an integral type and then carrying out the
	subtraction will break the dependency chain, so instead cast to
	a pointer to \co{char}.
	The Linux-kernel \co{container_of()} macro illustrates this.
	This macro is used to find the beginning of a structure given
	a pointer to a field within that same structure.
\item	Note that class-member access operators (\co{.} and \co{->})
	can be thought of as computing an offset as part of their
	execution.
\end{enumerate}

\paragraph{Dereferencing and Address-Of:}

Dereferencing a pointer that is part of a dependency chain extends the
dependency chain to the result, but only when the resulting value is a
pointer type.
Taking the address of a pointer that is part of a dependency chain,
and then dereferencing the resulting pointer, extends the dependency
chain to the result.

\begin{enumerate}
\item	If a pointer is part of a dependency chain, then dereferencing it
	using the prefix \co{*} operator extends the chain through
	the dereference operation.
	Line~24 of
	Figure~\ref{fig:List-Based-Stack Whole-Program Approach, 1 of 2}
	illustrates this, given that the \co{->t} acts as a pointer offset
	prior to indirection.
\item	If a pointer is part of a dependency chain, then dereferencing it
	using the \co{->} field-selection operator extends the
	chain to the field.
	Note that the when the \co{->} operator is followed by one or more
	\co{.} operators, these latter operators are equivalent to adding
	a constant integer to the original pointer.
	Line~24 of
	Figure~\ref{fig:List-Based-Stack Whole-Program Approach, 1 of 2}
	directly illustrates this rule.
\item	If a pointer is part of a dependency chain, then applying the
	unary \co{&} address-of operator, optionally casting this
	address to a pointer type (perhaps repeatedly to different pointer
	types, either explicitly or implicitly), then applying the
	\co{*} dereference operator extends the chain to the result.
	This is used by some of the Linux-kernel list-processing macros.
\end{enumerate}

\paragraph{Integer Operations:}

It is important to note that performing integer operations on pointer
values and then attempting to use the result as a pointer is outside
of the current standard.
Nevertheless, there are a great many use cases in this area, so
the following rules apply.
Please note that these rules cannot be part of the standard in its
current form, but instead must be negotiated with individual
implementers.

\begin{enumerate}
\item	If a value of type \co{intptr_t} or \co{uintptr_t} is part of a
	dependency chain, then the bitwise infix \co{&} and \co{|}
	operators extend the dependency chain to the resulting value.
	Line~5 of
	Figure~\ref{fig:Pointers and Bit Manipulation on 64-Bit System}
	illustrates this rule.
\item	If a value of type \co{intptr_t} or \co{uintptr_t} is part of a
	dependency chain, the the bitwise infix \co{^} operator extends
	the dependency chain to the resulting value.
	The use case for this traversal of buddy-allocator-like lists
	or dense-array heaps, but it is not clear whether these use
	cases justify this addition to dependency ordering.
\end{enumerate}

\paragraph{Miscellaneous Operations:}

The following operations also extend dependency chains.

\begin{enumerate}
\item	If a pointer is part of a dependency chain, and that pointer
	appears in the operand of a \co{?:} operator selected by
	the condition, then the chain extends to the result.
	Please note that \co{?:} does not extend chains from its
	condition, only from its second or third argument.
\item	If a pointer is part of a dependency chain, and that pointer
	appears in the right-hand operand of a \co{,} operator,
	then the chain extends to the result.
	Please note that the \co{,} operator does not extend chains from its
	left-hand operand, only from its right-hand operand.
\item	If a pointer to a function is part of a dependency chain, then
	invoking the pointed-to function extends the chain from the
	pointer to the instructions executed.
	Note that the exact mechanism used to update instructions is
	implementation defined, and might require use of special
	instruction-cache-flush operations.\footnote{
		This may sound strange, but just you try implementing
		dynamic linking without the ability to update instructions!
		That said, this is very clearly outside of the current
		standard, so this item is something to be negotiated
		with individual implementers.}
\item	If a given operation extends a dependency chain, then so does
	its atomic counterpart.
	For example, the rules applying to assignments also apply to
	atomic loads and stores.
	It also applies to atomic exchange and and atomic compare
	and swap.
\end{enumerate}

\subsubsection{Terminating Dependency Chains}
\label{sec:Terminating Dependency Chains}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 struct bar {
 2   struct bar *next;
 3   int a;
 4   int b;
 5 };
 6 struct bar *head = { &head, 1, 2 };
 7 
 8 for (p = head->next; p; p = rcu_dereference(p->next)) {
 9   foo += p->a;
10   if (p == &head)
11     break;
12 }
13 bar *= head->b;
\end{verbatim}
}
\caption{Back-Propagation of Dependency-Chain Breakage Due to Comparisons}
\label{fig:Back-Propagation of Dependency-Chain Breakage Due to Comparisons}
\end{figure}

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1   if (p > &foo)
 2     do_something(p);
 3   else if (p < &foo)
 4     do_something_else(p);
 5   else
 6     do_something_nodep(p);
\end{verbatim}
}
\caption{Inequality-Comparison Dependency-Chain Breakage}
\label{fig:Inequality-Comparison Dependency-Chain Breakage}
\end{figure}

Even though all other operations terminate dependency chains, there
are a few that deserve special mention:

\begin{enumerate}
\item	Equality comparisons.
\item	Narrowing magnitude comparisons.
\item	Narrowing arithmetic operations.
\item	Narrowing bitwise operations.
\item	Storing non-pointers into shared variables.
\item	Passing values between threads without using
	a \co{memory_order_consume} load.
\item	Undefined behavior.
\item	Use of \co{std::kill_dependency}.
\end{enumerate}

Each of these is covered below.

\paragraph{Equality comparisons:}
If a pointer is part of a dependency chain, then a \co{==}
or \co{!=} comparison that compares equal to some other pointer,
where that other pointer is not part of any dependency chain,
will cause any uses of the original pointer to no longer
be part of the dependency chain.
This dependency-chain breakage can back-propagate to earlier uses
of the pointer, so that in
Figure~\ref{fig:Back-Propagation of Dependency-Chain Breakage Due to Comparisons},
if the comparison on line~10 compares equal, then the access on
line~9 is not part of the dependency chain.
This is admittedly a rather strange code fragment, and besides,
the Linux-kernel \co{barrier()} macro could prevent this if
placed between lines~9 and~10.
Furthermore, the Linux kernel's list macros avoid this situation
because the equal comparison terminates the loop.

So what if the compiler introduces an equality comparison?
This might happen when doing feedback-directed optimization,
where the compiler might notice (for example) that a particularly
statically allocated structure was almost always the first
element on a given list.
The compiler might therefore introduce a specialization
optimization, comparing the addresses and generating code
using the statically allocated structure on equals
comparison.
On the one hand, in the cases where the Linux kernel adds
a statically allocated structure to an RCU-protected linked
data structure, that structure has been initialized at compile
time, so that dependency ordering is not required.
On the other hand, this appears to be an extremely dubious
optimization for linked data structures:  In a great many cases,
the added overhead of the comparison would overwhelm the benefits
of generating code based on the statically allocated
structure.

High-quality implementations would therefore be expected to
provide means for disabling this sort of optimization, especially
for pointers obtained from the heap.
After all, use of statically allocated structures in RCU-protected
lists could be quite useful during out-of-memory conditions,
in which case the specialization optimization would almost always
reduce performance, which is not what optmizations are supposed to be
doing.

Alternatively, an intrinsic could provide comparison, but avoid
breaking dependency chains.
For example, a \co{T std::pointer_cmp_eq_dep(T *pd, T* p)} intrinsic could
compare the two pointers, but perserve dependencies carried
by \co{pd} even if they compare equal.
For completeness, a \co{T std::pointer_cmp_ne_dep(T *pd, T* p)}
instrinic could also be provided for not-equal comparisons.
Note that there is no way to compare two pointers carrying
dependencies and preserve the dependency for both.
This is because there are currentely no use cases requiring this,
and requiring it would require the compiler to be less efficient
in its register usage.

\paragraph{Narrowing magnitude comparisons:}
A series of \co{>}, \co{<}, \co{>=}, or \co{<=} operators that
informs the compiler of the exact value of a pointer causes that
pointer to no longer be part of the dependency chain.
See Figure~\ref{fig:Inequality-Comparison Dependency-Chain Breakage}
for an example of this.
On line~6 of this figure, the compiler knows that the value of
\co{p} is equal to \co{\&foo}, so although there is dependency
ordering to lines~2 and~4, there is no dependency ordering to
line~6.
This dependency-chain breakage can back-propagate, just as
for equality comparisons.
However, dependencies are maintained for normal uses, for
example, the use of comparisons for deadlock avoidance
when acquiring locks contained in multiple RCU-protected
data elements.

As with equality comparison, an intrinsic could provide comparison, but avoid
breaking dependency chains.
For example,
\co{T std::pointer_cmp_gt_dep(T *pd, T* p)},
\co{T std::pointer_cmp_ge_dep(T *pd, T* p)},
\co{T std::pointer_cmp_lt_dep(T *pd, T* p)}, and
\co{T std::pointer_cmp_le_dep(T *pd, T* p)}
intrinsics could
compare the two pointers, but perserve dependencies carried
by \co{pd} even if a series of comparisons allowed the
compiler to deduce the exact value of the pointer.

\paragraph{Narrowing arithmetic operations:}
If a pointer is part of a dependency chain, and if the values
added to or subtracted from that pointer cancel the pointer
value so as to allow the compiler to precisely
determine the resulting value, then the resulting value will
not be part of any dependency chain.
For example, if \co{p} is part of a dependency chain, then
\co{((char *)p-(uintptr_t)p)+65536} will not be.\footnote{
	That said, 5.7p4 of C++ and 6.5.6p8 of C both say that
	indexing outside of an object is undefined behavior,
	so the loss of dependency ordering is likely the least of
	the problems here.}

\paragraph{Narrowing bitwise operations:}
If a value of type \co{intptr_t} or \co{uintptr_t} is part of a
dependency chain, and if that value is one of the operands
to an \co{&} or \co{|} infix operator whose
result has too few or too many bits set, then the resulting value will
not be part of any dependency chain.
For example, on a 64-bit system, if \co{p} is part of a
dependency chain, then \co{(p & 0x7)} provides just the
tag bits, and normally cannot even be legally dereferenced.
Similarly, \co{(p | ~0)} normally cannot be legally dereferenced.
However, \co{(p & ~0x7)} will provide a usable pointer that is
part of \co{p}'s dependency chain.
Setting or clearing bits that are not used by the implementation
or that would be zero for a properly aligned object will not
break the dependency chain.
That said, the compiler might not know the definition of
``properly aligned'', for example, in the cases of
manually cache-aligned or page-aligned objects.

Note that the \co{^} exclusive-OR operator can also break dependency
chains, most straightforwardly via something like \co{a ^ a}.

\paragraph{Storing non-pointers into shared variables:}
If a non-pointer value that is part of a dependency chain
is stored into a shared variable, then the dependency chain
does not extend to a later load from that variable.

\paragraph{Passing values between threads:}
If a value that is part of a dependency chain is stored into
a variable by one thread, and loaded from that same variable
by some other thread using either a non-atomic load or a
\co{memory_order_relaxed} load, then the dependency chain does
not extend to the second thread.
To get this effect, the second thread would instead need to use a
\co{memory_order_consume} load.
Note that this would extend the dependency chain even if the
corresponding store was a \co{memory_order_relaxed} store
because the required store-side ordering is provided by
the dependency chain.

\paragraph{Undefined behavior:}
If undefined behavior is invoked, then, consistent with the
notion of undefined behavior, there are no dependency-chain
guarantees.

If a given pointer, \co{intptr_t}, or \co{uintptr_t} is used
such that only one value avoids undefined behavior, then the
dependency chain is broken in the same way as it would be
in the case of an equality comparison with that same value.

\paragraph{kill\_dependency():}
The result of calling \co{std::kill_dependency} is never part of
any dependency chain.
This operation can be used to suppress diagnostics that implementations
might omit for likely misuses of dependency ordering.

\subsubsection{Restricted Dependency Chains and the Linux Kernel}
\label{sec:Restricted Dependency Chains and the Linux Kernel}

This covers all known pointer-based RCU uses in the Linux kernel,
aside from RCU-protected array indexes (more on these later).
However, as noted earlier, these restrictions might prove too constraining
for future code.
Therefore, it might be necessary to combine this approach with some
variation on one of the methods for explicitly marking variables, formal
parameters, and return values that are intended to carry dependencies.

Section~\ref{sec:Operators in Linux-Kernel Dependency Chains}
discussed dependency chains headed by
\co{memory_order_consume} loads of integers that are later used as
array indexes or pointer offsets.
Although there are a (very) few such uses in the Linux kernel, accommodating
dependency chains headed by loads of integers greatly complicates the
handling of dependency chains.\footnote{
	And for this reason, carrying of dependencies via integers is
	no longer supported in the Linux kernel as of v4.2, except in
	a few very restricted instances.}
For example, given an integer \co{x} produced by a \co{memory_order_consume}
load, we must correctly handle expressions containing \co{(x - x)}, including
cases where the cancellation is not at all obvious from the source code.
In contrast, given a pointer \co{p}, the expression \co{(p - p)} not a pointer,
and the rules given above do not require carrying a dependency through
such an expression.
This approach therefore excludes dependency chains headed by
\co{memory_order_consume} loads from non-pointer atomic variables.

This raises the question of what should be done about the Linux kernel
code that relies on ordering carried through integer array indexes.
Paul has answered this question by creating a Linux-kernel
patch that removes the kernel's dependency on RCU-protected array
indexes~\cite{PaulEMcKenney2015NoRCUArrayIndex}, and this patch
was accepted into the v4.2 release of the Linux kernel.

\begin{figure}[tbp]
{ \scriptsize
\begin{verbatim}
 1 p = atomic_load_explicit(gp, memory_order_consume);
 2 if (p == ptr_a) {
 3   q = std::kill_dependency(p);
 4   a = q->special_a;
 5 } else {
 6   a = p->normal_a;
 7 }
\end{verbatim}
}
\caption{Avoiding Diagnostic Due To Dependency-Ordering Value-Narrowing Hazard}
\label{fig:Avoiding Diagnostic Due To Dependency-Ordering Value-Narrowing Hazard}
\end{figure}

\subsubsection{Restricted Dependency Chains: Advantages and Disavantages}
\label{sec:Restricted Dependency Chains: Advantages and Disavantages}

This approach to dependency ordering has the following advantages and
disadvantages:

\begin{enumerate}
\item	There is no need for compilers to trace dependency chains.
	Instead, dependencies are an automatic result of current
	code-generation and optimization practices.
\item	There would be little or no limitation on compiler optimizations.
	Compilers are no longer required to establish artificial
	dependencies for expressions such as \co{(x - x)} or to
	detect value-narrowing hazards involving \co{==} and \co{!=}.
\item	The breaking of dependency chains when a pointer compares equal
	to some other pointer might prove to be onerous, but it is not
	a problem for current Linux use cases.\footnote{
		This needs to be re-verified.}
	The most common cases are comparison against a list header (in
	which case an equality comparison terminates the traversal)
	and comparison against NULL (in which case an equality comparison
	indicates a pointer that cannot be dereferenced in any case).
\item	The compiler is prohibited from carrying out value-speculation
	optimizations on pointers or values of type \co{intptr_t}
	or \co{uintptr_t} that have been cast from a pointer type
	and subjected to no operations other than infix \co{&}, \co{|},
	and \co{^}.
	(Is this an advantage or a disadvantage?
	The answer to this question is left to the reader.)
\item	In a great many cases, dependency chains can reliably pass through
	library functions compiled by pre-C11 compilers.
\item	It would not be necessary to use \co{std::kill_dependency()} calls
	in most cases.
	That said, use of \co{std::kill_dependency()} might at some
	future point allow the compiler to produce better diagnostics
	for dubious dependency-chain use cases.
	For example a compiler might issue a warning for the value-narrowing
	hazard shown on line~3 of
	Figure~\ref{fig:Dependency-Ordering Value-Narrowing Hazard},
	and that diagnostic might be suppressed as shown in
	Figure~\ref{fig:Avoiding Diagnostic Due To Dependency-Ordering Value-Narrowing Hazard}.
\item	More generally, this approach allows annotations to be discarded,
	as was shown in
	Figures~\ref{fig:List-Based-Stack Whole-Program Approach, 1 of 2}
	and~\ref{fig:List-Based-Stack Whole-Program Approach, 2 of 2}.
	However, the \co{memory_order_consume} loads are still required
	in order to support DEC Alpha and prevent compiler optimizations
	that might otherwise destroy the dependency chain.
\item	It would not be necessary to use \co{[[carries_dependency]]}
	attributes.
	However, as with \co{std::kill_dependency()}, use of something like
	\co{[[carries_dependency]]} might produce better diagnostics for
	dubious use dependency-chain use cases.
	That said, it might be preferable to substitute either type or
	object modifiers for attributes, given that use of attributes is
	not permitted to change the meaning of the program and also that
	attributes are not yet supported by the C language.
\item	With the exception of one use case involving arrays,
	no changes to the Linux-kernel source code are required.
	As noted earlier, a patch is available to remove the Linux
	kernel's dependency on RCU-protected array
	indexes~\cite{PaulEMcKenney2015NoRCUArrayIndex},
	and this patch was accepted into the v4.2 release of the
	Linux kernel.
\item	This approach has the advantage of implementation experience
	extending for more than two decades.
\end{enumerate}

In the future, this approach could be augmented by attributes, type
modifiers, object modifiers, or other markings to allow more elaborate
dependency chains to be created on the one hand, and to improve the
compiler's ability to emit diagnostics for dubious uses of dependency
chains on the other.

\subsection{Draft Wording for Restricted Dependency Chains}
\label{sec:Draft Wording for Restricted Dependency Chains}

Because bit manipulations on pointers results in undefined behavior,
the wording for this restricted-dependency-chain approach is considerably
simpler than might be expected.\footnote{
	Kudos to Jens Maurer for pointing this out.}
Although there are well-known and heavily used algorithms that depend
on setting tag bits on pointers, such algorithms must live outside of
the confines of the standard even without dependency chains.
This approach has the advantage that dependencies are then carried
only through pointer types, which greatly simplifies the specification.

1.10p11 of the most recent draft of the standard\cite{RichardSmith2015N4527},
is replaced with the following:

\begin{quote}
	An evaluation A \emph{carries a dependency} to an evaluation B
	of pointer type if
	\begin{itemize}
	\item	B is the invocation of an assignment operator and A is the
		right-hand operand of this operator, or
	\item	B is the invocation of a cast operator that is not
		a \co{reinterpret_cast} and A is the operand, or\footnote{
			The intent is that casts that leave pass through the
			bits carry a dependency, while those that affect
			the pointer value do not.}
	\item	B is a parameter to a function and A is the value of the
		corresponding argument, or
	\item	A is the value returned by a function and B is the returned
		value in the calling context, or
	\item	B is an additive operator, A is an operand to this operator,
		and the other operand is of integral type.
	\item	B is the prefix \co{*} dereference operation and A is its
		operand, or
	\item	B is the \co{->} class-member access operator and A is its
		left-hand operand, or
	\item	B is the \co{?:} operator and A is the operand selected by
		that operator's condition, or
	\item	B is the \co{,} operator and A is its rightmost operand, or
	\item	A writes a scalar object or bit-field M, B reads the value
		written by A from M, and A is sequenced before B, or
	\item	for some evaluations X and Y, X is the unary \co{&}
		operator, A is that operator's operand, X carries a
		dependency to Y, B is the the unary \co{*} operator,
		and Y is that operator's operand, or
	\item	for some evaluation X, A carries a dependency to X,
		and X carries a dependency to B.
	\end{itemize}

	An evaluation A carries a dependency to a side-effect C if
	\begin{itemize}
	\item	C is the side effect resulting from an assignment
		operator, and A is either operand of this operator, or
	\item	C is the side effect resulting from an atomic
		read-modify-write operation, A is its first argument,
		and the corresponding non-atomic operation would carry
		a dependency, or
	\item	C is the side effect resulting from an \co{atomic_store()}
		or \co{atomic_store_explicit()} function,
		and A is the function's second argument, or
	\item	C is the side effect resulting from an \co{atomic_exchange()}
		or \co{atomic_exchange_explicit()} function,
		and A is the function's second argument, or
	\item	C is the side effect resulting from an
		\co{atomic_compare_exchange_weak()},
		\co{atomic_exchange_weak_explicit()},
		\co{atomic_compare_exchange_strong()}, or
		\co{atomic_exchange_strong_explicit()}
		function, and A is the function's
		third (new-value) argument.
	\item	C is the side effect resulting from an atomic
		read-modify-write member function, A is the corresponding
		object, and the corresponding non-atomic operation would
		carry a dependency, or
	\item	C is the side effect resulting from a \co{store()}
		or \co{store_explicit()} member function,
		and A is the member function's first argument, or
	\item	C is the side effect resulting from an \co{exchange()}
		or \co{exchange_explicit()} member function,
		and A is the member function's first argument, or
	\item	C is the side effect resulting from a
		\co{compare_exchange_weak()},
		\co{exchange_weak_explicit()},
		\co{compare_exchange_strong()}, or
		\co{exchange_strong_explicit()}
		member function, and A is the member function's
		second (new-value) argument.
	\end{itemize}

	An evaluation A carries a dependency to a memory load D if
	\begin{itemize}
	\item	D is the memory load resulting from an \co{atomic_load()}
		or \co{atomic_load_explicit()} function,
		and A is the function's first argument, or
	\item	D is the memory load resulting from an atomic
		read-modify-write operation, A is its first argument,
		and the corresponding non-atomic operation would carry
		a dependency, or
	\item	D is the memory load resulting from an atomic
		read-modify-write member function, A is the corresponding
		object, and the corresponding non-atomic operation would
		carry a dependency.
	\end{itemize}

	If a pointer is subjected to a series of comparison operators
	that enables exact determination of its value, then no dependency
	is carried to that pointer.
	\emph{Note:} To carry out comparisons without destroying the
	dependency chain, use the
	\co{std::pointer_cmp_eq_dep()},
	\co{std::pointer_cmp_ne_dep()},
	\co{std::pointer_cmp_gt_dep()},
	\co{std::pointer_cmp_ge_dep()},
	\co{std::pointer_cmp_lt_dep()}, or
	\co{std::pointer_cmp_le_dep()}
	intrinsics.

	\emph{Note:} \co{std::kill_dependency()} is not mentioned above,
	so if A is its argument and B its result, no dependency is carried
	from A to B.

	\emph{Note:} The intent of these rules is to enable compilers
	to carry out their normal optimizations, while still permitting
	developers to rely on the common dependency-ordering use cases.

	\emph{Note:} Although the \co{[[carries_dependency]]} attribute
	is no longer needed to specify that a dependency chain exists,
	this attribute can help the implementation provide higher-quality
	diagnostics.
	For example, doing an equality comparison to a non-\co{NULL}
	pointer that is dereferenced could result in a warning
	diagnostic.
	Such a warning would make the user aware that no dependency was
	carried to that pointer.
\end{quote}

1.10p12 of the most recent draft is updated by inserting the phrase
``of pointer type'', resulting in`the following:

\begin{quote}
	An evaluation A is \emph{dependency-ordered before} an evaluation B if
	\begin{itemize}
	\item	A performs a release operation on an atomic object M
		of pointer type,
		and, in another thread, B performs a consume operation
		on M and reads a value written by any side effect in
		the release sequence headed by A, or
	\item	for some evaluation X, A is dependency-ordered before X
		and X carries a dependency to B.
	\end{itemize}
\end{quote}

\subsection{Storage Class}
\label{sec:Storage Class}

This approach, similar to that suggested by Lawrence Crowl in response to the
approach described in
Section~\ref{sec:Mark Dependency-Carrying Local Variables},
uses a new storage class to indicate where dependencies need
to be carried.
This section also applies lessons learned in discussions of the other
approaches, particularly those of
Sections~\ref{sec:Type-Based Designation of Dependency Chains},
\ref{sec:Local-Variable Restriction}
and~\ref{sec:Restricted Dependency Chains}.
In particular, this approach retains the restriction called out in
Section~\ref{sec:Restricted Dependency Chains}, namely allowing
dependencies to be carried only through pointer-like types,
including restricted operations on \co{intptr_t} and \co{uintptr_t}.\footnote{
	JF Bastien points out that in C++ this could be implemented
	as a class that is special in a manner similar to the atomic
	classes.
	One example of the special handling required is to preserve
	dependencies past successful pointer equality comparisons.
	However, a C-language implementation would require something
	resembling a storage class, so this proposal starts at that
	point.}

The idea is to provide a storage class \co{_Carries_dependency}
that indicates that the modified local variable, struct/union field,
function arguments, function parameters, or return value carries a dependency.
This is similar to the existing \co{[[carries_dependency]]}
attribute, but is usable by C (which lacks attributes) as well as
by C++, and which, unlike \co{[[carries_dependency]]}, is permitted
to change the program's semantics.
This last is important because it provides greater flexibility in
avoiding unsolicited (and costly) memory-fence instructions.

This approach results in the code shown in
Figures~\ref{fig:List-Based-Stack Marked Local Variables, 1 of 2}
and~\ref{fig:List-Based-Stack Marked Local Variables, 2 of 2}.

This approach uses strict dependencies rather than semantic dependencies,
which means that the implementation will need to emit explicit
memory-fence instructions in cases where the dependencies would
not be preserved by the underlying hardware.
However, high quality-of-implementation compilers would be expected to
provide options to issue warnings when such instructions were emitted,
allowing the developer to modify the code to avoid these expensive
instructions.
In addition, high quality-of-implementation compilers are expected
to carry dependencies past things like successful equality comparisons
with no performance degradation.
The operations carrying dependencies are exactly those shown
for the \emph{carries a dependency} relation shown in 1.10p11
of the standard~\cite{RichardSmith2015N4527}.

Assignment from an object with \co{_Carries_dependency} storage
class to an object not of this storage class would
act as an implicit \co{std::kill_dependency()}.
This is useful when protection of a given object is shifted from
a dependency chain to a lock or reference count.
However, high quality-of-implementation compilers would be
expected to provide options to issue warnings when such an implicit
\co{std::kill_dependency()} was encountered, which would allow
developers to enforce coding-style rules requiring explicit
\co{std::kill_dependency()}, if desired.

A high quality-of-implementation compiler would also be expected to
provide options to enable warnings to be issued when a dependency chain
was headed by something other than a \co{memory_order_consume}
load or an object with the \co{_Carries_dependency} storage class.
A cast could be used to suppress these warnings, which could be
provided as \co{std::unkill_dependency()} if experience indicates
that this is useful.
This \co{std::unkill_dependency()} is likely to be useful to enable
common code that traverses data structures using dependencies in some
cases and using mutual exclusion in other cases.

The new \co{_Carries_dependency} storage class may appear with
\co{register}, \co{static}, \co{thread_local}, and \co{extern}.
If \co{_Carries_dependency} appears in one declaration of a variable,
it shall appear in all other declarations of that entity.
The \co{_Carries_dependency} storage class can be applied only
to the names of variables, functions, formal parameters, and
structure/union fields.
Only variables of scalar or pointer type may be marked as
\co{_Carries_dependency}.\footnote{
	But if you have a valid use case for an aggregate construct
	that carries a dependency, please let us know.}

Here are use cases for the storage-class combinations:

\begin{itemize}
\item	\co{register _Carries_dependency}:  A local variable that
	carries a dependency that should also be stored in a
	machine register.
\item	\co{static _Carries_dependency}:  A static local variable
	that carries a dependency.
	Such a variable is presumably subject to some sort of
	mutual exclusion mechanism so as to avoid inter-thread
	access.
\item	\co{static thread_local _Carries_dependency}: A static
	thread-local variable that carries a dependency.
\item	\co{extern _Carries_dependency}: A variable shared among
	translation units that carries a dependency.
	Such a variable is presumably subject to some sort of
	mutual exclusion mechanism so as to avoid inter-thread
	access.
\item	\co{extern thread_local _Carries_dependency}: A
	thread-local variable shared among translation units
	that carries a dependency.
\item	\co{thread_local _Carries_dependency}: A
	thread-local variable that carries a dependency.
\end{itemize}

Again, this \co{_Carries_dependency} storage class can only be
applied to pointer-like types, with only restricted operations
permitted on \co{intptr_t} and \co{uintptr_t}
(see Section~\ref{sec:Extending Dependency Chains} for details).

This approach has the following advantages and disadvantages:

\begin{enumerate}
\item	The implementation is likely to be simpler in that dependencies
	need not be traced.
	Instead, only computations involving objects of the
	\co{_Carries_dependency} storage class need be handled specially.
	This eliminates unnecessary restriction of optimizations on
	unintentional dependency chains.
\item	The implicit \co{std::kill_dependency()} means that many
	irrelevant dependency chains are pruned by default, so
	that fewer explicit \co{std::kill_dependency()} invocations
	are required.
\item	Attributes need not be added to the C language.
\item	No modifications to the type system are required.
\item	Applying this to the Linux kernel would require significant
	marking of variables carrying dependencies, however,
	the Linux kernel is expected to use the approach called out in
	Section~\ref{sec:Restricted Dependency Chains}.
	Longer term, some portions of the Linux kernel might incrementally
	transition to this object-modifier approach, especially if doing
	so provides significant diagnostic benefits.
\item	The strict dependencies should permit tools based on formal
	methods to successfully analyze dependency chains.
	High quality tooling might well encourage existing RCU-using
	projects to adopt this storage-class-based approach.
\end{enumerate}

% \subsection{Evaluation}
% \label{sec:Evaluation}

This evaluation starts by enumerating the different audiences that any
change to \co{memory_order_consume} must address
(Section~\ref{sec:Audiences})
and then compares the various proposals based on the perceived viewpoints
of these audiences
(Section~\ref{sec:Comparison}).

\subsubsection{Audiences}
\label{sec:Audiences}

The main audiences for any change to \co{memory_order_consume} include
standards committee members, compiler implementers, formal-methods
researchers, developers intending to write new code, and developers working
with existing RCU code.
The Linux kernel community is of course a notable example of this
last category.

Standards committee members would like a clean and non-intrusive change
to the standard.
They would of course also like solutions minimizing the number and
vehemence of complaints from the other audiences, or, failing that,
reducing the complaints to a tolerable noise level.

Compiler implementers would like a mechanism that fits nicely into current
implementations, which does much to explain their satisfaction with the
approach of strengthening \co{memory_order_consume} to
\co{memory_order_acquire}.
In particular, they would like to avoid unbounded tracing of dependencies,
and would prefer minimal constraints on their ability to apply time-honored
optimizations.

Formal-methods researchers would like a definition of
\co{memory_order_consume} that fits into existing theoretical frameworks
without undue conceptual violence.
Of particular concern is any need to deal with counter-factuals, in other
words, any need to reason not only about values of variables required
for the solution of a given litmus test, but also about other unrelated
values for these variables.
As such, counter-factuals are the rock upon which otherwise attractive
approaches involving semantic dependency have foundered.\footnote{
	That said, Alan Jeffries is making another attempt to come up
	with a suitable formal definition of semantic dependency.}
Some practitioners might wonder why the opinion of formal-methods
researchers should be given any weight at all, and the answer to
this question is that it is the work of formal-methods
researchers that provides us the much-needed tools that we need
to analyze both the memory-ordering specification itself as well as
programs using that specification.

Developers writing new code need something that expresses their algorithm
with a minimum of syntactic saccharine, that is easy to learn, and that
is easy to maintain.
For example, one of the weaknesses of the current standards' definition of
\co{memory_order_consume} is the need to sprinkle large numbers of
\co{std::kill_dependency()} calls throughout one's code.
In short, developers would like it to be easy to write, analyze, and
maintain code that uses dependency ordering.

Developers with existing RCU code have the same desires as do developers
writing new code, but are also very interested in minimizing the code
churn required to adhere to the standard.

The challenge if of course to find a proposal that addresses the viewoints
of all of these audiences.
As we will see in the next session, this is not easy.
However, there is some hope that the approach presented in
Section~\ref{sec:Restricted Dependency Chains}
might suffice.

\subsubsection{Comparison}
\label{sec:Comparison}

\begin{table*}
\small
\begin{center}
\begin{tabular}{p{2.5in}||c|c|c|c|c|c|c|c|c|c|c|c}
	~ ~ ~ ~ ~ ~ ~ ~ ~
	& \begin{picture}(6,130)(0,0)
		\rotatebox{90}{Dependency Type}
	  \end{picture}
	& \begin{picture}(7,130)(0,0)
		\rotatebox{90}{Object Marking}
	  \end{picture}
	& \begin{picture}(7,130)(0,0)
		\rotatebox{90}{Formal-Parameter Marking}
	  \end{picture}
	& \begin{picture}(6,130)(0,0)
		\rotatebox{90}{Return-Value Marking}
	  \end{picture}
	& \begin{picture}(6,130)(0,0)
		\rotatebox{90}{Beginning-Of-Chain Handling}
	  \end{picture}
	& \begin{picture}(6,130)(0,0)
		\rotatebox{90}{End-Of-Chain Handling}
	  \end{picture}
	& \begin{picture}(6,130)(0,0)
		\rotatebox{90}{Dependency Tracing Required}
	  \end{picture}
	& \begin{picture}(6,130)(0,0)
		\rotatebox{90}{C Attribute Support Required}
	  \end{picture}
	& \begin{picture}(6,130)(0,0)
		\rotatebox{90}{Diagnostic Capability}
	  \end{picture}
	& \begin{picture}(6,130)(0,0)
		\rotatebox{90}{Unsolicited Memory Fences}
	  \end{picture}
	& \begin{picture}(6,130)(0,0)
		\rotatebox{90}{Linux-Kernel Compatibility}
	  \end{picture}
	& \begin{picture}(6,130)(0,0)
		\rotatebox{90}{Suitable for Formal Verification}
	  \end{picture}
	\\
	\hline
%	  DT     OM  FPM    RVM   BEOCH  EOCH   DTR  CAR  DC  UMF LKC SFV
	\hline
	C11 / C++11
	& dep   & ~ & A   & A   &      & K    & Y  & Y  & n & Y & N &   \\
	\hline
	Type-Based Designation of Dependency Chains With Restrictions
	(Section~\ref{sec:Type-Based Designation of Dependency Chains With Restrictions})
	& lsdep & T & T   & T   &      & k    & ~  & ~  & ? & Y & N & N \\
	\hline
	Type-Based Designation of Dependency Chains
	(Section~\ref{sec:Type-Based Designation of Dependency Chains})
	& dep   & T & T  & T   &      & k     & ~  & ~  & ? & Y & N &   \\
	\hline
	Whole-Program Option
	(Section~\ref{sec:Whole-Program Option})
	& sdep  & ~ & ~   & ~  &      &       & ~  & ~  & N &   &   & N \\
	\hline
	Local-Variable Restriction
	(Section~\ref{sec:Local-Variable Restriction})
	& dep   & ~ & A   & A  &      & k     & ~  & Y  & ? & Y & N &   \\
	\hline
	Mark Dependency-Carrying Local Variables
	(Section~\ref{sec:Mark Dependency-Carrying Local Variables})
	& dep   & A & A   & A  &      & k     & ~  & Y  & ? & Y & N &   \\
	\hline
	Explicitly Tail-Marked Dependency Chains
	(Section~\ref{sec:Explicitly Tail-Marked Dependency Chains})
	& dep   & ~ & A   & A  &      & Dk    & y  & Y  & N & Y & N & ? \\
	\hline
	Explicitly Head-Marked Dependency Chains
	(Section~\ref{sec:Explicitly Head-Marked Dependency Chains})
	& dep   & ~ & ?   & ?  & D    & k     & y  & Y  & N & Y & N & ? \\
	\hline
	Restricted Dependency Chains
	(Section~\ref{sec:Restricted Dependency Chains})
	& rdep  & ~ & ~   & ~  & ~    & ~     & ~  & ~  & N & ~ & ~ & N \\
	\hline
	Storage Class
	(Section~\ref{sec:Storage Class})
	& rdep  & S & S   & S  & ~    & ~     & ~  & ~  & ~ & Y & N & ~ \\
\multicolumn{9}{l}{~} \\
\multicolumn{9}{l}{Marking:
		   ``A'': attribute, ``S'': Object, ``T'': type.} \\
\multicolumn{9}{l}{Beginning of chain:
		   ``D'': explicit designation.} \\
\multicolumn{9}{l}{End of chain:
		   ``D'': explicit designation,
		   ``k/K'': implicit/explicit \co{std::kill_dependency}.} \\
\multicolumn{9}{l}{Dependency tracking required:
		   ``y'': only for marked chains,
		   ``Y'': always.} \\
\multicolumn{9}{l}{Diagnostic capability:
		   ``n'': incomplete,
		   ``N'': very limited,
		   ``?'': could be provided.} \\
\end{tabular}
\end{center}
\caption{Comparison of Consume Proposals}
\label{tab:Comparison of Consume Proposals}
\end{table*}

A summary comparison of the proposals is shown in
Table~\ref{tab:Comparison of Consume Proposals}.

The dependency type can either be ``dep'' for normal dependency,
``rdep'' for the restricted dependencies discussed in
Section~\ref{sec:Restricted Dependency Chains},
``sdep'' for (global) semantic dependency, or ``lsdep'' for local
semantic dependency.\footnote{
	Recall that a local semantic dependency remains a dependency
	even if the \co{memory_order_consume} load at its head can return
	only a single value.
	In contrast, a global semantic dependency remains a dependency
	only if more than one value can appear at the end of the chain.
	Therefore, optimizations based on global full-program analysis
	can break a global semantic dependency
	but can break neither a local semantic dependency nor a
	normal dependency.}
Variable, formal-parameter, and return-value marking can either be
type-based (``T''),
storage-class-based (``S''),
attribute-based (``A''),
or not required (``~'').
Beginning-of-chain handling can either require explicit indication to
which quantities dependencies must be carried (``D'') or
nothing (``~'').
End-of-chain handling can either require an explicit
\co{std::kill_dependency} (``K''), an implicit \co{std::kill_dependency} (``k''),
explicit designation of dependency (``D''), or
nothing (``~'').\footnote{
	Variables that go out of scope always have any dependency chain
	implicitly killed.}
Dependency tracking might be required for all chains (``Y''),
explicitly designated chains (``y''), or not required at all (``~'').
C-language \co{[[carries_dependency]]} support might be required (``Y'')
or not (``~'').
Diagnostic capability is difficult to evaluate for many of the proposals,
but for some proposals it is limited (``n''),
for others quite difficult (``N''), and
for still others too early to tell (``?'').
Some proposals inflict unsolicited memory fences on developers (``Y''),
and others do not (`` ''), and
some proposals are source-code compatible with the Linux kernel (`` ''),
while others are not (``N'').
Anything other than pure syntactic dependendencies (``dep'') are quite
challenging for current formal-verification tools, resulting in most
proposals getting (``N'') or (``?'').

The ideal proposal would have dependency type ``dep''
(thus making it easier to model dependency ordering and making it
unnecessary for developer to have to outwit full-program optimizations),
no need for variable, formal-parameter, or return-value marking
(thus minimizing changes required for existing RCU code),
implicit ``do the right thing'' end-of-chain handling,\footnote{
	Perhaps implemented by a careful choice of exactly which
	operators carry dependencies in which situations.}
(thus minimizing the need for whack-a-mole source-code markups),
no need for dependency tracking
(thus making it easier to implement),
no need for C-language support for the \co{[[carries_dependency]]} attribute
(thus minimizing changes to the C standard),
good diagnostic capabilities, refrain from supplying
unsolicited memory fences, be source-code compatible with the
Linux kernel, and lend itself well to analysis by formal-verification
tools.

However, there appears to be no such proposal possible, so the
recommended approach is to use the restricted dependency chains
discussed in
Section~\ref{sec:Restricted Dependency Chains}
for large existing code bases and the storage-class approach discussed in
Section~\ref{sec:Storage Class}
for new code and perhaps also as a future direction for large existing
code bases.

\section{Summary}
\label{sec:Summary}

This document has analyzed Linux-kernel use of dependency ordering and
has laid out the status-quo interaction between the Linux kernel and
pre-C11 compilers.
It has also put forward some possible ways of building towards
a full implementation of C11's and
C++11's handling of dependency ordering.
It calls out some weaknesses in C11's and C++11's handling
of dependency ordering and offers some alternatives.
Finally, it recommends one approach
(Section~\ref{sec:Restricted Dependency Chains})
for large existing code bases and a second approach
(Section~\ref{sec:Storage Class})
for new code bases.
Over time, it is hoped that the availability of diagnostic tools will
motivate migration to the second of these two approaches.

%\input{acknowledgments}
%\input{legal}

%\bibliographystyle{abbrv}
%\softraggedright

\bibliographystyle{acm}
\bibliography{bib/RCU,bib/WFS,bib/hw,bib/os,bib/parallelsys,bib/patterns,bib/perfmeas,bib/refs,bib/syncrefs,bib/search,bib/swtools,bib/realtime,bib/TM,bib/standards,bib/maze}

% \section*{Change Log}
% \label{sec:Change Log}

% This paper first appeared as {\bf N4026} in May of 2014.
% Revisions to this document are as follows:

% \begin{itemize}
% \item	Mark the paper as a revision of N4036.
% 	(July 17, 2014.)
% \end{itemize}

% At this point, the paper was published as {\bf P0098R1}.

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% for Ispell:
% LocalWords:  workingdraft BCM ednote SubSections xfig SubSection

